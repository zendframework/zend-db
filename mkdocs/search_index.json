{
    "docs": [
        {
            "location": "/",
            "text": "zend-db\n\n\n\n\n\n\nZend\\Db\n is a component that abstract the access to a Database using an object\noriented API to build the queries. \nZend\\Db\n consumes different storage adapters\nto access different database vendors such as MySQL, PostgreSQL, Oracle, IBM DB2,\nMicrosoft Sql Server, PDO, etc.\n\n\n\n\nFile issues at https://github.com/zendframework/zend-db/issues\n\n\nDocumentation is at https://zendframework.github.io/zend-db/",
            "title": "Home"
        },
        {
            "location": "/#zend-db",
            "text": "Zend\\Db  is a component that abstract the access to a Database using an object\noriented API to build the queries.  Zend\\Db  consumes different storage adapters\nto access different database vendors such as MySQL, PostgreSQL, Oracle, IBM DB2,\nMicrosoft Sql Server, PDO, etc.   File issues at https://github.com/zendframework/zend-db/issues  Documentation is at https://zendframework.github.io/zend-db/",
            "title": "zend-db"
        },
        {
            "location": "/adapter/",
            "text": "Adapters\n\n\nZend\\Db\\Adapter\\Adapter\n is the central object of the zend-db component. It is\nresponsible for adapting any code written in or for zend-db to the targeted PHP\nextensions and vendor databases. In doing this, it creates an abstraction layer\nfor the PHP extensions in the \nDriver\n subnamespace of \nZend\\Db\\Adapter\n.  It\nalso creates a lightweight \"Platform\" abstraction layer, for the various\nidiosyncrasies that each vendor-specific platform might have in its SQL/RDBMS\nimplementation, separate from the driver implementations.\n\n\nCreating an adapter using configuration\n\n\nCreate an adapter by instantiating the \nZend\\Db\\Adapter\\Adapter\n class. The most\ncommon use case, while not the most explicit, is to pass an array of\nconfiguration to the \nAdapter\n:\n\n\nuse Zend\\Db\\Adapter\\Adapter;\n\n$adapter = new Adapter($configArray);\n\n\n\nThis driver array is an abstraction for the extension level required parameters.\nHere is a table for the key-value pairs that should be in configuration array.\n\n\n\n\n\n\n\n\nKey\n\n\nIs Required?\n\n\nValue\n\n\n\n\n\n\n\n\n\n\ndriver\n\n\nrequired\n\n\nMysqli\n, \nSqlsrv\n, \nPdo_Sqlite\n, \nPdo_Mysql\n, \nPdo\n(= Other PDO Driver)\n\n\n\n\n\n\ndatabase\n\n\ngenerally required\n\n\nthe name of the database (schema)\n\n\n\n\n\n\nusername\n\n\ngenerally required\n\n\nthe connection username\n\n\n\n\n\n\npassword\n\n\ngenerally required\n\n\nthe connection password\n\n\n\n\n\n\nhostname\n\n\nnot generally required\n\n\nthe IP address or hostname to connect to\n\n\n\n\n\n\nport\n\n\nnot generally required\n\n\nthe port to connect to (if applicable)\n\n\n\n\n\n\ncharset\n\n\nnot generally required\n\n\nthe character set to use\n\n\n\n\n\n\n\n\n\n\nOptions are adapter-dependent\n\n\nOther names will work as well. Effectively, if the PHP manual uses a\nparticular naming, this naming will be supported by the associated driver. For\nexample, \ndbname\n in most cases will also work for 'database'.  Another\nexample is that in the case of \nSqlsrv\n, \nUID\n will work in place of\n\nusername\n. Which format you choose is up to you, but the above table\nrepresents the official abstraction names.\n\n\n\n\nFor example, a MySQL connection using ext/mysqli:\n\n\n$adapter = new Zend\\Db\\Adapter\\Adapter([\n    'driver'   => 'Mysqli',\n    'database' => 'zend_db_example',\n    'username' => 'developer',\n    'password' => 'developer-password',\n]);\n\n\n\nAnother example, of a Sqlite connection via PDO:\n\n\n$adapter = new Zend\\Db\\Adapter\\Adapter([\n    'driver'   => 'Pdo_Sqlite',\n    'database' => 'path/to/sqlite.db',\n]);\n\n\n\nIt is important to know that by using this style of adapter creation, the\n\nAdapter\n will attempt to create any dependencies that were not explicitly\nprovided. A \nDriver\n object will be created from the configuration array\nprovided in the constructor. A \nPlatform\n object will be created based off the\ntype of \nDriver\n class that was instantiated. And lastly, a default \nResultSet\n\nobject is created and utilized. Any of these objects can be injected, to do\nthis, see the next section.\n\n\nThe list of officially supported drivers:\n\n\n\n\nIbmDb2\n: The ext/ibm_db2 driver\n\n\nMysqli\n: The ext/mysqli driver\n\n\nOci8\n: The ext/oci8 driver\n\n\nPgsql\n: The ext/pgsql driver\n\n\nSqlsrv\n: The ext/sqlsrv driver (from Microsoft)\n\n\nPdo_Mysql\n: MySQL via the PDO extension\n\n\nPdo_Sqlite\n: SQLite via the PDO extension\n\n\nPdo_Pgsql\n: PostgreSQL via the PDO extension\n\n\n\n\nCreating an adapter using dependency injection\n\n\nThe more expressive and explicit way of creating an adapter is by injecting all\nyour dependencies up front. \nZend\\Db\\Adapter\\Adapter\n uses constructor\ninjection, and all required dependencies are injected through the constructor,\nwhich has the following signature (in pseudo-code):\n\n\nuse Zend\\Db\\Adapter\\Platform\\PlatformInterface;\nuse Zend\\Db\\ResultSet\\ResultSet;\n\nclass Zend\\Db\\Adapter\\Adapter\n{\n    public function __construct(\n        $driver,\n        PlatformInterface $platform = null,\n        ResultSet $queryResultSetPrototype = null\n    );\n}\n\n\n\nWhat can be injected:\n\n\n\n\n$driver\n: an array of connection parameters (see above) or an instance of\n  \nZend\\Db\\Adapter\\Driver\\DriverInterface\n.\n\n\n$platform\n (optional): an instance of \nZend\\Db\\Platform\\PlatformInterface\n;\n  the default will be created based off the driver implementation.\n\n\n$queryResultSetPrototype\n (optional): an instance of\n  \nZend\\Db\\ResultSet\\ResultSet\n; to understand this object's role, see the\n  section below on querying.\n\n\n\n\nQuery Preparation\n\n\nBy default, \nZend\\Db\\Adapter\\Adapter::query()\n prefers that you use\n\"preparation\" as a means for processing SQL statements.  This generally means\nthat you will supply a SQL statement containing placeholders for the values, and\nseparately provide substitutions for those placeholders. As an example:\n\n\n$adapter->query('SELECT * FROM `artist` WHERE `id` = ?', [5]);\n\n\n\nThe above example will go through the following steps:\n\n\n\n\ncreate a new \nStatement\n object.\n\n\nprepare the array \n[5]\n into a \nParameterContainer\n if necessary.\n\n\ninject the \nParameterContainer\n into the \nStatement\n object.\n\n\nexecute the \nStatement\n object, producing a \nResult\n object.\n\n\ncheck the \nResult\n object to check if the supplied SQL was a result set\n  producing statement:\n\n\nif the query produced a result set, clone the \nResultSet\n prototype,\n  inject the \nResult\n as its datasource, and return the new \nResultSet\n\n  instance.\n\n\notherwise, return the \nResult\n.\n\n\n\n\n\n\n\n\nQuery Execution\n\n\nIn some cases, you have to execute statements directly without preparation. One\npossible reason for doing so would be to execute a DDL statement, as most\nextensions and RDBMS systems are incapable of preparing such statements.\n\n\nTo execute a query without the preparation step, you will need to pass a flag as\nthe second argument indicating execution is required:\n\n\n$adapter->query(\n    'ALTER TABLE ADD INDEX(`foo_index`) ON (`foo_column`)',\n    Adapter::QUERY_MODE_EXECUTE\n);\n\n\n\nThe primary difference to notice is that you must provide the\n\nAdapter::QUERY_MODE_EXECUTE\n (execute) flag as the second parameter.\n\n\nCreating Statements\n\n\nWhile \nquery()\n is highly useful for one-off and quick querying of a database\nvia the \nAdapter\n, it generally makes more sense to create a statement and\ninteract with it directly, so that you have greater control over the\nprepare-then-execute workflow. To do this, \nAdapter\n gives you a routine called\n\ncreateStatement()\n that allows you to create a \nDriver\n specific \nStatement\n to\nuse so you can manage your own prepare-then-execute workflow.\n\n\n// with optional parameters to bind up-front:\n$statement = $adapter->createStatement($sql, $optionalParameters);\n$result    = $statement->execute();\n\n\n\nUsing the Driver Object\n\n\nThe \nDriver\n object is the primary place where \nZend\\Db\\Adapter\\Adapter\n\nimplements the connection level abstraction specific to a given extension.  To\nmake this possible, each driver is composed of 3 objects:\n\n\n\n\nA connection: \nZend\\Db\\Adapter\\Driver\\ConnectionInterface\n\n\nA statement: \nZend\\Db\\Adapter\\Driver\\StatementInterface\n\n\nA result: \nZend\\Db\\Adapter\\Driver\\ResultInterface\n\n\n\n\nEach of the built-in drivers practice \"prototyping\" as a means of creating\nobjects when new instances are requested. The workflow looks like this:\n\n\n\n\nAn adapter is created with a set of connection parameters.\n\n\nThe adapter chooses the proper driver to instantiate (for example,\n  \nZend\\Db\\Adapter\\Driver\\Mysqli\n)\n\n\nThat driver class is instantiated.\n\n\nIf no connection, statement, or result objects are injected, defaults are\n  instantiated.\n\n\n\n\nThis driver is now ready to be called on when particular workflows are\nrequested. Here is what the \nDriver\n API looks like:\n\n\nnamespace Zend\\Db\\Adapter\\Driver;\n\ninterface DriverInterface\n{\n    const PARAMETERIZATION_POSITIONAL = 'positional';\n    const PARAMETERIZATION_NAMED = 'named';\n    const NAME_FORMAT_CAMELCASE = 'camelCase';\n    const NAME_FORMAT_NATURAL = 'natural';\n\n    public function getDatabasePlatformName(string $nameFormat = self::NAME_FORMAT_CAMELCASE) : string;\n    public function checkEnvironment() : bool;\n    public function getConnection() : ConnectionInterface;\n    public function createStatement(string|resource $sqlOrResource = null) : StatementInterface;\n    public function createResult(resource $resource) : ResultInterface;\n    public function getPrepareType() :string;\n    public function formatParameterName(string $name, $type = null) : string;\n    public function getLastGeneratedValue() : mixed;\n}\n\n\n\nFrom this \nDriverInterface\n, you can\n\n\n\n\nDetermine the name of the platform this driver supports (useful for choosing\n  the proper platform object).\n\n\nCheck that the environment can support this driver.\n\n\nReturn the \nConnection\n instance.\n\n\nCreate a \nStatement\n instance which is optionally seeded by an SQL statement\n  (this will generally be a clone of a prototypical statement object).\n\n\nCreate a \nResult\n object which is optionally seeded by a statement resource\n  (this will generally be a clone of a prototypical result object)\n\n\nFormat parameter names; this is important to distinguish the difference\n  between the various ways parameters are named between extensions\n\n\nRetrieve the overall last generated value (such as an auto-increment value).\n\n\n\n\nNow let's turn to the \nStatement\n API:\n\n\nnamespace Zend\\Db\\Adapter\\Driver;\n\ninterface StatementInterface extends StatementContainerInterface\n{\n    public function getResource() : resource;\n    public function prepare($sql = null) : void;\n    public function isPrepared() : bool;\n    public function execute(null|array|ParameterContainer $parameters = null) : ResultInterface;\n\n    /** Inherited from StatementContainerInterface */\n    public function setSql(string $sql) : void;\n    public function getSql() : string;\n    public function setParameterContainer(ParameterContainer $parameterContainer) : void;\n    public function getParameterContainer() : ParameterContainer;\n}\n\n\n\nAnd finally, the \nResult\n API:\n\n\nnamespace Zend\\Db\\Adapter\\Driver;\n\nuse Countable;\nuse Iterator;\n\ninterface ResultInterface extends Countable, Iterator\n{\n    public function buffer() : void;\n    public function isQueryResult() : bool;\n    public function getAffectedRows() : int;\n    public function getGeneratedValue() : mixed;\n    public function getResource() : resource;\n    public function getFieldCount() : int;\n}\n\n\n\nUsing The Platform Object\n\n\nThe \nPlatform\n object provides an API to assist in crafting queries in a way\nthat is specific to the SQL implementation of a particular vendor. The object\nhandles nuances such as how identifiers or values are quoted, or what the\nidentifier separator character is. To get an idea of the capabilities, the\ninterface for a platform object looks like this:\n\n\nnamespace Zend\\Db\\Adapter\\Platform;\n\ninterface PlatformInterface\n{\n    public function getName() : string;\n    public function getQuoteIdentifierSymbol() : string;\n    public function quoteIdentifier(string $identifier) : string;\n    public function quoteIdentifierChain(string|string[] $identiferChain) : string;\n    public function getQuoteValueSymbol() : string;\n    public function quoteValue(string $value) : string;\n    public function quoteTrustedValue(string $value) : string;\n    public function quoteValueList(string|string[] $valueList) : string;\n    public function getIdentifierSeparator() : string;\n    public function quoteIdentifierInFragment(string $identifier, array $additionalSafeWords = []) : string;\n}\n\n\n\nWhile you can directly instantiate a \nPlatform\n object, generally speaking, it\nis easier to get the proper \nPlatform\n instance from the configured adapter (by\ndefault the \nPlatform\n type will match the underlying driver implementation):\n\n\n$platform = $adapter->getPlatform();\n\n// or\n$platform = $adapter->platform; // magic property access\n\n\n\nThe following are examples of \nPlatform\n usage:\n\n\n// $adapter is a Zend\\Db\\Adapter\\Adapter instance;\n// $platform is a Zend\\Db\\Adapter\\Platform\\Sql92 instance.\n$platform = $adapter->getPlatform();\n\n// \"first_name\"\necho $platform->quoteIdentifier('first_name');\n\n// \"\necho $platform->getQuoteIdentifierSymbol();\n\n// \"schema\".\"mytable\"\necho $platform->quoteIdentifierChain(['schema', 'mytable']);\n\n// '\necho $platform->getQuoteValueSymbol();\n\n// 'myvalue'\necho $platform->quoteValue('myvalue');\n\n// 'value', 'Foo O\\\\'Bar'\necho $platform->quoteValueList(['value', \"Foo O'Bar\"]);\n\n// .\necho $platform->getIdentifierSeparator();\n\n// \"foo\" as \"bar\"\necho $platform->quoteIdentifierInFragment('foo as bar');\n\n// additionally, with some safe words:\n// (\"foo\".\"bar\" = \"boo\".\"baz\")\necho $platform->quoteIdentifierInFragment('(foo.bar = boo.baz)', ['(', ')', '=']);\n\n\n\nUsing The Parameter Container\n\n\nThe \nParameterContainer\n object is a container for the various parameters that\nneed to be passed into a \nStatement\n object to fulfill all the various\nparameterized parts of the SQL statement. This object implements the\n\nArrayAccess\n interface. Below is the \nParameterContainer\n API:\n\n\nnamespace Zend\\Db\\Adapter;\n\nuse ArrayAccess;\nuse ArrayIterator;\nuse Countable;\nuse Iterator;\n\nclass ParameterContainer implements Iterator, ArrayAccess, Countable\n{\n    public function __construct(array $data = [])\n\n    /** methods to interact with values */\n    public function offsetExists(string|int $name) : bool;\n    public function offsetGet(string|int $name) : mixed;\n    public function offsetSetReference(string|int $name, string|int $from) : void;\n    public function offsetSet(string|int $name, mixed $value, mixed $errata = null, int $maxLength = null) : void;\n    public function offsetUnset(string|int $name) : void;\n\n    /** set values from array (will reset first) */\n    public function setFromArray(array $data) : ParameterContainer;\n\n    /** methods to interact with value errata */\n    public function offsetSetErrata(string|int $name, mixed $errata) : void;\n    public function offsetGetErrata(string|int $name) : mixed;\n    public function offsetHasErrata(string|int $name) : bool;\n    public function offsetUnsetErrata(string|int $name) : void;\n\n    /** errata only iterator */\n    public function getErrataIterator() : ArrayIterator;\n\n    /** get array with named keys */\n    public function getNamedArray() : array;\n\n    /** get array with int keys, ordered by position */\n    public function getPositionalArray() : array;\n\n    /** iterator: */\n    public function count() : int;\n    public function current() : mixed;\n    public function next() : mixed;\n    public function key() : string|int;\n    public function valid() : bool;\n    public function rewind() : void;\n\n    /** merge existing array of parameters with existing parameters */\n    public function merge(array $parameters) : ParameterContainer;\n}\n\n\n\nIn addition to handling parameter names and values, the container will assist in\ntracking parameter types for PHP type to SQL type handling. For example, it\nmight be important that:\n\n\n$container->offsetSet('limit', 5);\n\n\n\nbe bound as an integer. To achieve this, pass in the\n\nParameterContainer::TYPE_INTEGER\n constant as the 3rd parameter:\n\n\n$container->offsetSet('limit', 5, $container::TYPE_INTEGER);\n\n\n\nThis will ensure that if the underlying driver supports typing of bound\nparameters, that this translated information will also be passed along to the\nactual php database driver.\n\n\nExamples\n\n\nCreating a \nDriver\n, a vendor-portable query, and preparing and iterating the\nresult:\n\n\n$adapter = new Zend\\Db\\Adapter\\Adapter($driverConfig);\n\n$qi = function ($name) use ($adapter) {\n    return $adapter->platform->quoteIdentifier($name);\n};\n$fp = function ($name) use ($adapter) {\n    return $adapter->driver->formatParameterName($name);\n};\n\n$sql = 'UPDATE ' . $qi('artist')\n    . ' SET ' . $qi('name') . ' = ' . $fp('name')\n    . ' WHERE ' . $qi('id') . ' = ' . $fp('id');\n\n$statement = $adapter->query($sql);\n\n$parameters = [\n    'name' => 'Updated Artist',\n    'id'   => 1,\n];\n\n$statement->execute($parameters);\n\n// DATA INSERTED, NOW CHECK\n\n$statement = $adapter->query(\n    'SELECT * FROM '\n    . $qi('artist')\n    . ' WHERE id = ' . $fp('id')\n);\n\n$results = $statement->execute(['id' => 1]);\n\n$row = $results->current();\n$name = $row['name'];",
            "title": "Adapters"
        },
        {
            "location": "/adapter/#adapters",
            "text": "Zend\\Db\\Adapter\\Adapter  is the central object of the zend-db component. It is\nresponsible for adapting any code written in or for zend-db to the targeted PHP\nextensions and vendor databases. In doing this, it creates an abstraction layer\nfor the PHP extensions in the  Driver  subnamespace of  Zend\\Db\\Adapter .  It\nalso creates a lightweight \"Platform\" abstraction layer, for the various\nidiosyncrasies that each vendor-specific platform might have in its SQL/RDBMS\nimplementation, separate from the driver implementations.",
            "title": "Adapters"
        },
        {
            "location": "/adapter/#creating-an-adapter-using-configuration",
            "text": "Create an adapter by instantiating the  Zend\\Db\\Adapter\\Adapter  class. The most\ncommon use case, while not the most explicit, is to pass an array of\nconfiguration to the  Adapter :  use Zend\\Db\\Adapter\\Adapter;\n\n$adapter = new Adapter($configArray);  This driver array is an abstraction for the extension level required parameters.\nHere is a table for the key-value pairs that should be in configuration array.     Key  Is Required?  Value      driver  required  Mysqli ,  Sqlsrv ,  Pdo_Sqlite ,  Pdo_Mysql ,  Pdo (= Other PDO Driver)    database  generally required  the name of the database (schema)    username  generally required  the connection username    password  generally required  the connection password    hostname  not generally required  the IP address or hostname to connect to    port  not generally required  the port to connect to (if applicable)    charset  not generally required  the character set to use",
            "title": "Creating an adapter using configuration"
        },
        {
            "location": "/adapter/#options-are-adapter-dependent",
            "text": "Other names will work as well. Effectively, if the PHP manual uses a\nparticular naming, this naming will be supported by the associated driver. For\nexample,  dbname  in most cases will also work for 'database'.  Another\nexample is that in the case of  Sqlsrv ,  UID  will work in place of username . Which format you choose is up to you, but the above table\nrepresents the official abstraction names.   For example, a MySQL connection using ext/mysqli:  $adapter = new Zend\\Db\\Adapter\\Adapter([\n    'driver'   => 'Mysqli',\n    'database' => 'zend_db_example',\n    'username' => 'developer',\n    'password' => 'developer-password',\n]);  Another example, of a Sqlite connection via PDO:  $adapter = new Zend\\Db\\Adapter\\Adapter([\n    'driver'   => 'Pdo_Sqlite',\n    'database' => 'path/to/sqlite.db',\n]);  It is important to know that by using this style of adapter creation, the Adapter  will attempt to create any dependencies that were not explicitly\nprovided. A  Driver  object will be created from the configuration array\nprovided in the constructor. A  Platform  object will be created based off the\ntype of  Driver  class that was instantiated. And lastly, a default  ResultSet \nobject is created and utilized. Any of these objects can be injected, to do\nthis, see the next section.  The list of officially supported drivers:   IbmDb2 : The ext/ibm_db2 driver  Mysqli : The ext/mysqli driver  Oci8 : The ext/oci8 driver  Pgsql : The ext/pgsql driver  Sqlsrv : The ext/sqlsrv driver (from Microsoft)  Pdo_Mysql : MySQL via the PDO extension  Pdo_Sqlite : SQLite via the PDO extension  Pdo_Pgsql : PostgreSQL via the PDO extension",
            "title": "Options are adapter-dependent"
        },
        {
            "location": "/adapter/#creating-an-adapter-using-dependency-injection",
            "text": "The more expressive and explicit way of creating an adapter is by injecting all\nyour dependencies up front.  Zend\\Db\\Adapter\\Adapter  uses constructor\ninjection, and all required dependencies are injected through the constructor,\nwhich has the following signature (in pseudo-code):  use Zend\\Db\\Adapter\\Platform\\PlatformInterface;\nuse Zend\\Db\\ResultSet\\ResultSet;\n\nclass Zend\\Db\\Adapter\\Adapter\n{\n    public function __construct(\n        $driver,\n        PlatformInterface $platform = null,\n        ResultSet $queryResultSetPrototype = null\n    );\n}  What can be injected:   $driver : an array of connection parameters (see above) or an instance of\n   Zend\\Db\\Adapter\\Driver\\DriverInterface .  $platform  (optional): an instance of  Zend\\Db\\Platform\\PlatformInterface ;\n  the default will be created based off the driver implementation.  $queryResultSetPrototype  (optional): an instance of\n   Zend\\Db\\ResultSet\\ResultSet ; to understand this object's role, see the\n  section below on querying.",
            "title": "Creating an adapter using dependency injection"
        },
        {
            "location": "/adapter/#query-preparation",
            "text": "By default,  Zend\\Db\\Adapter\\Adapter::query()  prefers that you use\n\"preparation\" as a means for processing SQL statements.  This generally means\nthat you will supply a SQL statement containing placeholders for the values, and\nseparately provide substitutions for those placeholders. As an example:  $adapter->query('SELECT * FROM `artist` WHERE `id` = ?', [5]);  The above example will go through the following steps:   create a new  Statement  object.  prepare the array  [5]  into a  ParameterContainer  if necessary.  inject the  ParameterContainer  into the  Statement  object.  execute the  Statement  object, producing a  Result  object.  check the  Result  object to check if the supplied SQL was a result set\n  producing statement:  if the query produced a result set, clone the  ResultSet  prototype,\n  inject the  Result  as its datasource, and return the new  ResultSet \n  instance.  otherwise, return the  Result .",
            "title": "Query Preparation"
        },
        {
            "location": "/adapter/#query-execution",
            "text": "In some cases, you have to execute statements directly without preparation. One\npossible reason for doing so would be to execute a DDL statement, as most\nextensions and RDBMS systems are incapable of preparing such statements.  To execute a query without the preparation step, you will need to pass a flag as\nthe second argument indicating execution is required:  $adapter->query(\n    'ALTER TABLE ADD INDEX(`foo_index`) ON (`foo_column`)',\n    Adapter::QUERY_MODE_EXECUTE\n);  The primary difference to notice is that you must provide the Adapter::QUERY_MODE_EXECUTE  (execute) flag as the second parameter.",
            "title": "Query Execution"
        },
        {
            "location": "/adapter/#creating-statements",
            "text": "While  query()  is highly useful for one-off and quick querying of a database\nvia the  Adapter , it generally makes more sense to create a statement and\ninteract with it directly, so that you have greater control over the\nprepare-then-execute workflow. To do this,  Adapter  gives you a routine called createStatement()  that allows you to create a  Driver  specific  Statement  to\nuse so you can manage your own prepare-then-execute workflow.  // with optional parameters to bind up-front:\n$statement = $adapter->createStatement($sql, $optionalParameters);\n$result    = $statement->execute();",
            "title": "Creating Statements"
        },
        {
            "location": "/adapter/#using-the-driver-object",
            "text": "The  Driver  object is the primary place where  Zend\\Db\\Adapter\\Adapter \nimplements the connection level abstraction specific to a given extension.  To\nmake this possible, each driver is composed of 3 objects:   A connection:  Zend\\Db\\Adapter\\Driver\\ConnectionInterface  A statement:  Zend\\Db\\Adapter\\Driver\\StatementInterface  A result:  Zend\\Db\\Adapter\\Driver\\ResultInterface   Each of the built-in drivers practice \"prototyping\" as a means of creating\nobjects when new instances are requested. The workflow looks like this:   An adapter is created with a set of connection parameters.  The adapter chooses the proper driver to instantiate (for example,\n   Zend\\Db\\Adapter\\Driver\\Mysqli )  That driver class is instantiated.  If no connection, statement, or result objects are injected, defaults are\n  instantiated.   This driver is now ready to be called on when particular workflows are\nrequested. Here is what the  Driver  API looks like:  namespace Zend\\Db\\Adapter\\Driver;\n\ninterface DriverInterface\n{\n    const PARAMETERIZATION_POSITIONAL = 'positional';\n    const PARAMETERIZATION_NAMED = 'named';\n    const NAME_FORMAT_CAMELCASE = 'camelCase';\n    const NAME_FORMAT_NATURAL = 'natural';\n\n    public function getDatabasePlatformName(string $nameFormat = self::NAME_FORMAT_CAMELCASE) : string;\n    public function checkEnvironment() : bool;\n    public function getConnection() : ConnectionInterface;\n    public function createStatement(string|resource $sqlOrResource = null) : StatementInterface;\n    public function createResult(resource $resource) : ResultInterface;\n    public function getPrepareType() :string;\n    public function formatParameterName(string $name, $type = null) : string;\n    public function getLastGeneratedValue() : mixed;\n}  From this  DriverInterface , you can   Determine the name of the platform this driver supports (useful for choosing\n  the proper platform object).  Check that the environment can support this driver.  Return the  Connection  instance.  Create a  Statement  instance which is optionally seeded by an SQL statement\n  (this will generally be a clone of a prototypical statement object).  Create a  Result  object which is optionally seeded by a statement resource\n  (this will generally be a clone of a prototypical result object)  Format parameter names; this is important to distinguish the difference\n  between the various ways parameters are named between extensions  Retrieve the overall last generated value (such as an auto-increment value).   Now let's turn to the  Statement  API:  namespace Zend\\Db\\Adapter\\Driver;\n\ninterface StatementInterface extends StatementContainerInterface\n{\n    public function getResource() : resource;\n    public function prepare($sql = null) : void;\n    public function isPrepared() : bool;\n    public function execute(null|array|ParameterContainer $parameters = null) : ResultInterface;\n\n    /** Inherited from StatementContainerInterface */\n    public function setSql(string $sql) : void;\n    public function getSql() : string;\n    public function setParameterContainer(ParameterContainer $parameterContainer) : void;\n    public function getParameterContainer() : ParameterContainer;\n}  And finally, the  Result  API:  namespace Zend\\Db\\Adapter\\Driver;\n\nuse Countable;\nuse Iterator;\n\ninterface ResultInterface extends Countable, Iterator\n{\n    public function buffer() : void;\n    public function isQueryResult() : bool;\n    public function getAffectedRows() : int;\n    public function getGeneratedValue() : mixed;\n    public function getResource() : resource;\n    public function getFieldCount() : int;\n}",
            "title": "Using the Driver Object"
        },
        {
            "location": "/adapter/#using-the-platform-object",
            "text": "The  Platform  object provides an API to assist in crafting queries in a way\nthat is specific to the SQL implementation of a particular vendor. The object\nhandles nuances such as how identifiers or values are quoted, or what the\nidentifier separator character is. To get an idea of the capabilities, the\ninterface for a platform object looks like this:  namespace Zend\\Db\\Adapter\\Platform;\n\ninterface PlatformInterface\n{\n    public function getName() : string;\n    public function getQuoteIdentifierSymbol() : string;\n    public function quoteIdentifier(string $identifier) : string;\n    public function quoteIdentifierChain(string|string[] $identiferChain) : string;\n    public function getQuoteValueSymbol() : string;\n    public function quoteValue(string $value) : string;\n    public function quoteTrustedValue(string $value) : string;\n    public function quoteValueList(string|string[] $valueList) : string;\n    public function getIdentifierSeparator() : string;\n    public function quoteIdentifierInFragment(string $identifier, array $additionalSafeWords = []) : string;\n}  While you can directly instantiate a  Platform  object, generally speaking, it\nis easier to get the proper  Platform  instance from the configured adapter (by\ndefault the  Platform  type will match the underlying driver implementation):  $platform = $adapter->getPlatform();\n\n// or\n$platform = $adapter->platform; // magic property access  The following are examples of  Platform  usage:  // $adapter is a Zend\\Db\\Adapter\\Adapter instance;\n// $platform is a Zend\\Db\\Adapter\\Platform\\Sql92 instance.\n$platform = $adapter->getPlatform();\n\n// \"first_name\"\necho $platform->quoteIdentifier('first_name');\n\n// \"\necho $platform->getQuoteIdentifierSymbol();\n\n// \"schema\".\"mytable\"\necho $platform->quoteIdentifierChain(['schema', 'mytable']);\n\n// '\necho $platform->getQuoteValueSymbol();\n\n// 'myvalue'\necho $platform->quoteValue('myvalue');\n\n// 'value', 'Foo O\\\\'Bar'\necho $platform->quoteValueList(['value', \"Foo O'Bar\"]);\n\n// .\necho $platform->getIdentifierSeparator();\n\n// \"foo\" as \"bar\"\necho $platform->quoteIdentifierInFragment('foo as bar');\n\n// additionally, with some safe words:\n// (\"foo\".\"bar\" = \"boo\".\"baz\")\necho $platform->quoteIdentifierInFragment('(foo.bar = boo.baz)', ['(', ')', '=']);",
            "title": "Using The Platform Object"
        },
        {
            "location": "/adapter/#using-the-parameter-container",
            "text": "The  ParameterContainer  object is a container for the various parameters that\nneed to be passed into a  Statement  object to fulfill all the various\nparameterized parts of the SQL statement. This object implements the ArrayAccess  interface. Below is the  ParameterContainer  API:  namespace Zend\\Db\\Adapter;\n\nuse ArrayAccess;\nuse ArrayIterator;\nuse Countable;\nuse Iterator;\n\nclass ParameterContainer implements Iterator, ArrayAccess, Countable\n{\n    public function __construct(array $data = [])\n\n    /** methods to interact with values */\n    public function offsetExists(string|int $name) : bool;\n    public function offsetGet(string|int $name) : mixed;\n    public function offsetSetReference(string|int $name, string|int $from) : void;\n    public function offsetSet(string|int $name, mixed $value, mixed $errata = null, int $maxLength = null) : void;\n    public function offsetUnset(string|int $name) : void;\n\n    /** set values from array (will reset first) */\n    public function setFromArray(array $data) : ParameterContainer;\n\n    /** methods to interact with value errata */\n    public function offsetSetErrata(string|int $name, mixed $errata) : void;\n    public function offsetGetErrata(string|int $name) : mixed;\n    public function offsetHasErrata(string|int $name) : bool;\n    public function offsetUnsetErrata(string|int $name) : void;\n\n    /** errata only iterator */\n    public function getErrataIterator() : ArrayIterator;\n\n    /** get array with named keys */\n    public function getNamedArray() : array;\n\n    /** get array with int keys, ordered by position */\n    public function getPositionalArray() : array;\n\n    /** iterator: */\n    public function count() : int;\n    public function current() : mixed;\n    public function next() : mixed;\n    public function key() : string|int;\n    public function valid() : bool;\n    public function rewind() : void;\n\n    /** merge existing array of parameters with existing parameters */\n    public function merge(array $parameters) : ParameterContainer;\n}  In addition to handling parameter names and values, the container will assist in\ntracking parameter types for PHP type to SQL type handling. For example, it\nmight be important that:  $container->offsetSet('limit', 5);  be bound as an integer. To achieve this, pass in the ParameterContainer::TYPE_INTEGER  constant as the 3rd parameter:  $container->offsetSet('limit', 5, $container::TYPE_INTEGER);  This will ensure that if the underlying driver supports typing of bound\nparameters, that this translated information will also be passed along to the\nactual php database driver.",
            "title": "Using The Parameter Container"
        },
        {
            "location": "/adapter/#examples",
            "text": "Creating a  Driver , a vendor-portable query, and preparing and iterating the\nresult:  $adapter = new Zend\\Db\\Adapter\\Adapter($driverConfig);\n\n$qi = function ($name) use ($adapter) {\n    return $adapter->platform->quoteIdentifier($name);\n};\n$fp = function ($name) use ($adapter) {\n    return $adapter->driver->formatParameterName($name);\n};\n\n$sql = 'UPDATE ' . $qi('artist')\n    . ' SET ' . $qi('name') . ' = ' . $fp('name')\n    . ' WHERE ' . $qi('id') . ' = ' . $fp('id');\n\n$statement = $adapter->query($sql);\n\n$parameters = [\n    'name' => 'Updated Artist',\n    'id'   => 1,\n];\n\n$statement->execute($parameters);\n\n// DATA INSERTED, NOW CHECK\n\n$statement = $adapter->query(\n    'SELECT * FROM '\n    . $qi('artist')\n    . ' WHERE id = ' . $fp('id')\n);\n\n$results = $statement->execute(['id' => 1]);\n\n$row = $results->current();\n$name = $row['name'];",
            "title": "Examples"
        },
        {
            "location": "/result-set/",
            "text": "Result Sets\n\n\nZend\\Db\\ResultSet\n is a sub-component of zend-db for abstracting the iteration\nof results returned from queries producing rowsets. While data sources for this\ncan be anything that is iterable, generally these will be populated from\n\nZend\\Db\\Adapter\\Driver\\ResultInterface\n instances.\n\n\nResult sets must implement the \nZend\\Db\\ResultSet\\ResultSetInterface\n, and all\nsub-components of zend-db that return a result set as part of their API will\nassume an instance of a \nResultSetInterface\n should be returned. In most cases,\nthe prototype pattern will be used by consuming object to clone a prototype of\na \nResultSet\n and return a specialized \nResultSet\n with a specific data source\ninjected. \nResultSetInterface\n is defined as follows:\n\n\nuse Countable;\nuse Traversable;\n\ninterface ResultSetInterface extends Traversable, Countable\n{\n    public function initialize(mixed $dataSource) : void;\n    public function getFieldCount() : int;\n}\n\n\n\nQuick start\n\n\nZend\\Db\\ResultSet\\ResultSet\n is the most basic form of a \nResultSet\n object\nthat will expose each row as either an \nArrayObject\n-like object or an array of\nrow data. By default, \nZend\\Db\\Adapter\\Adapter\n will use a prototypical\n\nZend\\Db\\ResultSet\\ResultSet\n object for iterating when using the\n\nZend\\Db\\Adapter\\Adapter::query()\n method.\n\n\nThe following is an example workflow similar to what one might find inside\n\nZend\\Db\\Adapter\\Adapter::query()\n:\n\n\nuse Zend\\Db\\Adapter\\Driver\\ResultInterface;\nuse Zend\\Db\\ResultSet\\ResultSet;\n\n$statement = $driver->createStatement('SELECT * FROM users');\n$statement->prepare();\n$result = $statement->execute($parameters);\n\nif ($result instanceof ResultInterface && $result->isQueryResult()) {\n    $resultSet = new ResultSet;\n    $resultSet->initialize($result);\n\n    foreach ($resultSet as $row) {\n        echo $row->my_column . PHP_EOL;\n    }\n}\n\n\n\nZend\\Db\\ResultSet\\ResultSet and Zend\\Db\\ResultSet\\AbstractResultSet\n\n\nFor most purposes, either an instance of \nZend\\Db\\ResultSet\\ResultSet\n or a\nderivative of \nZend\\Db\\ResultSet\\AbstractResultSet\n will be used. The\nimplementation of the \nAbstractResultSet\n offers the following core\nfunctionality:\n\n\nnamespace Zend\\Db\\ResultSet;\n\nuse Iterator;\n\nabstract class AbstractResultSet implements Iterator, ResultSetInterface\n{\n    public function initialize(array|Iterator|IteratorAggregate|ResultInterface $dataSource) : self;\n    public function getDataSource() : Iterator|IteratorAggregate|ResultInterface;\n    public function getFieldCount() : int;\n\n    /** Iterator */\n    public function next() : mixed;\n    public function key() : string|int;\n    public function current() : mixed;\n    public function valid() : bool;\n    public function rewind() : void;\n\n    /** countable */\n    public function count() : int;\n\n    /** get rows as array */\n    public function toArray() : array;\n}\n\n\n\nZend\\Db\\ResultSet\\HydratingResultSet\n\n\nZend\\Db\\ResultSet\\HydratingResultSet\n is a more flexible \nResultSet\n object\nthat allows the developer to choose an appropriate \"hydration strategy\" for\ngetting row data into a target object.  While iterating over results,\n\nHydratingResultSet\n will take a prototype of a target object and clone it once\nfor each row. The \nHydratingResultSet\n will then hydrate that clone with the\nrow data.\n\n\nThe \nHydratingResultSet\n depends on\n\nzend-hydrator\n, which you will\nneed to install:\n\n\n$ composer require zendframework/zend-hydrator\n\n\n\nIn the example below, rows from the database will be iterated, and during\niteration, \nHydratingResultSet\n will use the \nReflection\n based hydrator to\ninject the row data directly into the protected members of the cloned\n\nUserEntity\n object:\n\n\nuse Zend\\Db\\Adapter\\Driver\\ResultInterface;\nuse Zend\\Db\\ResultSet\\HydratingResultSet;\nuse Zend\\Hydrator\\Reflection as ReflectionHydrator;\n\nclass UserEntity\n{\n    protected $first_name;\n    protected $last_name;\n\n    public function getFirstName()\n    {\n        return $this->first_name;\n    }\n\n    public function getLastName()\n    {\n        return $this->last_name;\n    }\n\n    public function setFirstName($firstName)\n    {\n        $this->first_name = $firstName;\n    }\n\n    public function setLastName($lastName)\n    {\n        $this->last_name = $lastName;\n    }\n}\n\n$statement = $driver->createStatement($sql);\n$statement->prepare($parameters);\n$result = $statement->execute();\n\nif ($result instanceof ResultInterface && $result->isQueryResult()) {\n    $resultSet = new HydratingResultSet(new ReflectionHydrator, new UserEntity);\n    $resultSet->initialize($result);\n\n    foreach ($resultSet as $user) {\n        echo $user->getFirstName() . ' ' . $user->getLastName() . PHP_EOL;\n    }\n}\n\n\n\nFor more information, see the \nzend-hydrator\n\ndocumentation to get a better sense of the different strategies that can be\nemployed in order to populate a target object.",
            "title": "Result Sets"
        },
        {
            "location": "/result-set/#result-sets",
            "text": "Zend\\Db\\ResultSet  is a sub-component of zend-db for abstracting the iteration\nof results returned from queries producing rowsets. While data sources for this\ncan be anything that is iterable, generally these will be populated from Zend\\Db\\Adapter\\Driver\\ResultInterface  instances.  Result sets must implement the  Zend\\Db\\ResultSet\\ResultSetInterface , and all\nsub-components of zend-db that return a result set as part of their API will\nassume an instance of a  ResultSetInterface  should be returned. In most cases,\nthe prototype pattern will be used by consuming object to clone a prototype of\na  ResultSet  and return a specialized  ResultSet  with a specific data source\ninjected.  ResultSetInterface  is defined as follows:  use Countable;\nuse Traversable;\n\ninterface ResultSetInterface extends Traversable, Countable\n{\n    public function initialize(mixed $dataSource) : void;\n    public function getFieldCount() : int;\n}",
            "title": "Result Sets"
        },
        {
            "location": "/result-set/#quick-start",
            "text": "Zend\\Db\\ResultSet\\ResultSet  is the most basic form of a  ResultSet  object\nthat will expose each row as either an  ArrayObject -like object or an array of\nrow data. By default,  Zend\\Db\\Adapter\\Adapter  will use a prototypical Zend\\Db\\ResultSet\\ResultSet  object for iterating when using the Zend\\Db\\Adapter\\Adapter::query()  method.  The following is an example workflow similar to what one might find inside Zend\\Db\\Adapter\\Adapter::query() :  use Zend\\Db\\Adapter\\Driver\\ResultInterface;\nuse Zend\\Db\\ResultSet\\ResultSet;\n\n$statement = $driver->createStatement('SELECT * FROM users');\n$statement->prepare();\n$result = $statement->execute($parameters);\n\nif ($result instanceof ResultInterface && $result->isQueryResult()) {\n    $resultSet = new ResultSet;\n    $resultSet->initialize($result);\n\n    foreach ($resultSet as $row) {\n        echo $row->my_column . PHP_EOL;\n    }\n}",
            "title": "Quick start"
        },
        {
            "location": "/result-set/#zend92db92resultset92resultset-and-zend92db92resultset92abstractresultset",
            "text": "For most purposes, either an instance of  Zend\\Db\\ResultSet\\ResultSet  or a\nderivative of  Zend\\Db\\ResultSet\\AbstractResultSet  will be used. The\nimplementation of the  AbstractResultSet  offers the following core\nfunctionality:  namespace Zend\\Db\\ResultSet;\n\nuse Iterator;\n\nabstract class AbstractResultSet implements Iterator, ResultSetInterface\n{\n    public function initialize(array|Iterator|IteratorAggregate|ResultInterface $dataSource) : self;\n    public function getDataSource() : Iterator|IteratorAggregate|ResultInterface;\n    public function getFieldCount() : int;\n\n    /** Iterator */\n    public function next() : mixed;\n    public function key() : string|int;\n    public function current() : mixed;\n    public function valid() : bool;\n    public function rewind() : void;\n\n    /** countable */\n    public function count() : int;\n\n    /** get rows as array */\n    public function toArray() : array;\n}",
            "title": "Zend\\Db\\ResultSet\\ResultSet and Zend\\Db\\ResultSet\\AbstractResultSet"
        },
        {
            "location": "/result-set/#zend92db92resultset92hydratingresultset",
            "text": "Zend\\Db\\ResultSet\\HydratingResultSet  is a more flexible  ResultSet  object\nthat allows the developer to choose an appropriate \"hydration strategy\" for\ngetting row data into a target object.  While iterating over results, HydratingResultSet  will take a prototype of a target object and clone it once\nfor each row. The  HydratingResultSet  will then hydrate that clone with the\nrow data.  The  HydratingResultSet  depends on zend-hydrator , which you will\nneed to install:  $ composer require zendframework/zend-hydrator  In the example below, rows from the database will be iterated, and during\niteration,  HydratingResultSet  will use the  Reflection  based hydrator to\ninject the row data directly into the protected members of the cloned UserEntity  object:  use Zend\\Db\\Adapter\\Driver\\ResultInterface;\nuse Zend\\Db\\ResultSet\\HydratingResultSet;\nuse Zend\\Hydrator\\Reflection as ReflectionHydrator;\n\nclass UserEntity\n{\n    protected $first_name;\n    protected $last_name;\n\n    public function getFirstName()\n    {\n        return $this->first_name;\n    }\n\n    public function getLastName()\n    {\n        return $this->last_name;\n    }\n\n    public function setFirstName($firstName)\n    {\n        $this->first_name = $firstName;\n    }\n\n    public function setLastName($lastName)\n    {\n        $this->last_name = $lastName;\n    }\n}\n\n$statement = $driver->createStatement($sql);\n$statement->prepare($parameters);\n$result = $statement->execute();\n\nif ($result instanceof ResultInterface && $result->isQueryResult()) {\n    $resultSet = new HydratingResultSet(new ReflectionHydrator, new UserEntity);\n    $resultSet->initialize($result);\n\n    foreach ($resultSet as $user) {\n        echo $user->getFirstName() . ' ' . $user->getLastName() . PHP_EOL;\n    }\n}  For more information, see the  zend-hydrator \ndocumentation to get a better sense of the different strategies that can be\nemployed in order to populate a target object.",
            "title": "Zend\\Db\\ResultSet\\HydratingResultSet"
        },
        {
            "location": "/sql/",
            "text": "SQL Abstraction\n\n\nZend\\Db\\Sql\n is a SQL abstraction layer for building platform-specific SQL\nqueries via an object-oriented API. The end result of a \nZend\\Db\\Sql\n object\nwill be to either produce a \nStatement\n and \nParameterContainer\n that\nrepresents the target query, or a full string that can be directly executed\nagainst the database platform. To achieve this, \nZend\\Db\\Sql\n objects require a\n\nZend\\Db\\Adapter\\Adapter\n object in order to produce the desired results.\n\n\nQuick start\n\n\nThere are four primary tasks associated with interacting with a database\ndefined by Data Manipulation Language (DML): selecting, inserting, updating,\nand deleting. As such, there are four primary classes that developers can\ninteract with in order to build queries in the \nZend\\Db\\Sql\n namespace:\n\nSelect\n, \nInsert\n, \nUpdate\n, and \nDelete\n.\n\n\nSince these four tasks are so closely related and generally used together\nwithin the same application, the \nZend\\Db\\Sql\\Sql\n class helps you create them\nand produce the result you are attempting to achieve.\n\n\nuse Zend\\Db\\Sql\\Sql;\n\n$sql    = new Sql($adapter);\n$select = $sql->select(); // returns a Zend\\Db\\Sql\\Select instance\n$insert = $sql->insert(); // returns a Zend\\Db\\Sql\\Insert instance\n$update = $sql->update(); // returns a Zend\\Db\\Sql\\Update instance\n$delete = $sql->delete(); // returns a Zend\\Db\\Sql\\Delete instance\n\n\n\nAs a developer, you can now interact with these objects, as described in the\nsections below, to customize each query. Once they have been populated with\nvalues, they are ready to either be prepared or executed.\n\n\nTo prepare (using a Select object):\n\n\nuse Zend\\Db\\Sql\\Sql;\n\n$sql    = new Sql($adapter);\n$select = $sql->select();\n$select->from('foo');\n$select->where(['id' => 2]);\n\n$statement = $sql->prepareStatementForSqlObject($select);\n$results = $statement->execute();\n\n\n\nTo execute (using a Select object)\n\n\nuse Zend\\Db\\Sql\\Sql;\n\n$sql    = new Sql($adapter);\n$select = $sql->select();\n$select->from('foo');\n$select->where(['id' => 2]);\n\n$selectString = $sql->buildSqlString($select);\n$results = $adapter->query($selectString, $adapter::QUERY_MODE_EXECUTE);\n\n\n\nZend\\\\Db\\\\Sql\\\\Sql\n objects can also be bound to a particular table so that in\nobtaining a \nSelect\n, \nInsert\n, \nUpdate\n, or \nDelete\n instance, the object will be\nseeded with the table:\n\n\nuse Zend\\Db\\Sql\\Sql;\n\n$sql    = new Sql($adapter, 'foo');\n$select = $sql->select();\n$select->where(['id' => 2]); // $select already has from('foo') applied\n\n\n\nCommon interfaces for SQL implementations\n\n\nEach of these objects implements the following two interfaces:\n\n\ninterface PreparableSqlInterface\n{\n     public function prepareStatement(Adapter $adapter, StatementInterface $statement) : void;\n}\n\ninterface SqlInterface\n{\n     public function getSqlString(PlatformInterface $adapterPlatform = null) : string;\n}\n\n\n\nUse these functions to produce either (a) a prepared statement, or (b) a string\nto execute.\n\n\nSelect\n\n\nZend\\Db\\Sql\\Select\n presents a unified API for building platform-specific SQL\nSELECT queries. Instances may be created and consumed without\n\nZend\\Db\\Sql\\Sql\n:\n\n\nuse Zend\\Db\\Sql\\Select;\n\n$select = new Select();\n// or, to produce a $select bound to a specific table\n$select = new Select('foo');\n\n\n\nIf a table is provided to the \nSelect\n object, then \nfrom()\n cannot be called\nlater to change the name of the table.\n\n\nOnce you have a valid \nSelect\n object, the following API can be used to further\nspecify various select statement parts:\n\n\nclass Select extends AbstractSql implements SqlInterface, PreparableSqlInterface\n{\n    const JOIN_INNER = 'inner';\n    const JOIN_OUTER = 'outer';\n    const JOIN_LEFT = 'left';\n    const JOIN_RIGHT = 'right';\n    const SQL_STAR = '*';\n    const ORDER_ASCENDING = 'ASC';\n    const ORDER_DESCENDING = 'DESC';\n\n    public $where; // @param Where $where\n\n    public function __construct(string|array|TableIdentifier $table = null);\n    public function from(string|array|TableIdentifier $table) : self;\n    public function columns(array $columns, bool $prefixColumnsWithTable = true) : self;\n    public function join(string|array $name, string $on, string|array $columns = self::SQL_STAR, string $type = self::JOIN_INNER) : self;\n    public function where(Where|callable|string|array|PredicateInterface $predicate, string $combination = Predicate\\PredicateSet::OP_AND) : self;\n    public function group(string|array $group);\n    public function having(Having|callable|string|array $predicate, string $combination = Predicate\\PredicateSet::OP_AND) : self;\n    public function order(string|array $order) : self;\n    public function limit(int $limit) : self;\n    public function offset(int $offset) : self;\n}\n\n\n\nfrom()\n\n\n// As a string:\n$select->from('foo');\n\n// As an array to specify an alias\n// (produces SELECT \"t\".* FROM \"table\" AS \"t\")\n$select->from(['t' => 'table']);\n\n// Using a Sql\\TableIdentifier:\n// (same output as above)\n$select->from(['t' => new TableIdentifier('table')]);\n\n\n\ncolumns()\n\n\n// As an array of names\n$select->columns(['foo', 'bar']);\n\n// As an associative array with aliases as the keys\n// (produces 'bar' AS 'foo', 'bax' AS 'baz')\n$select->columns(['foo' => 'bar', 'baz' => 'bax']);\n\n\n\njoin()\n\n\n$select->join(\n    'foo',              // table name\n    'id = bar.id',      // expression to join on (will be quoted by platform object before insertion),\n    ['bar', 'baz'],     // (optional) list of columns, same requirements as columns() above\n    $select::JOIN_OUTER // (optional), one of inner, outer, left, right also represented by constants in the API\n);\n\n$select\n    ->from(['f' => 'foo'])     // base table\n    ->join(\n        ['b' => 'bar'],        // join table with alias\n        'f.foo_id = b.foo_id'  // join expression\n    );\n\n\n\nwhere(), having()\n\n\nZend\\Db\\Sql\\Select\n provides bit of flexibility as it regards to what kind of\nparameters are acceptable when calling \nwhere()\n or \nhaving()\n. The method\nsignature is listed as:\n\n\n/**\n * Create where clause\n *\n * @param  Where|callable|string|array $predicate\n * @param  string $combination One of the OP_* constants from Predicate\\PredicateSet\n * @return Select\n */\npublic function where($predicate, $combination = Predicate\\PredicateSet::OP_AND);\n\n\n\nIf you provide a \nZend\\Db\\Sql\\Where\n instance to \nwhere()\n or a\n\nZend\\Db\\Sql\\Having\n instance to \nhaving()\n, any previous internal instances\nwill be replaced completely. When either instance is processed, this object will\nbe iterated to produce the WHERE or HAVING section of the SELECT statement.\n\n\nIf you provide a PHP callable to \nwhere()\n or \nhaving()\n, this function will be\ncalled with the \nSelect\n's \nWhere\n/\nHaving\n instance as the only parameter.\nThis enables code like the following:\n\n\n$select->where(function (Where $where) {\n    $where->like('username', 'ralph%');\n});\n\n\n\nIf you provide a \nstring\n, this string will be used to create a\n\nZend\\Db\\Sql\\Predicate\\Expression\n instance, and its contents will be applied\nas-is, with no quoting:\n\n\n// SELECT \"foo\".* FROM \"foo\" WHERE x = 5\n$select->from('foo')->where('x = 5');\n\n\n\nIf you provide an array with integer indices, the value can be one of:\n\n\n\n\na string; this will be used to build a \nPredicate\\Expression\n.\n\n\nany object implementing \nPredicate\\PredicateInterface\n.\n\n\n\n\nIn either case, the instances are pushed onto the \nWhere\n stack with the\n\n$combination\n provided (defaulting to \nAND\n).\n\n\nAs an example:\n\n\n// SELECT \"foo\".* FROM \"foo\" WHERE x = 5 AND y = z\n$select->from('foo')->where(['x = 5', 'y = z']);\n\n\n\nIf you provide an associative array with string keys, any value with a string\nkey will be cast as follows:\n\n\n\n\n\n\n\n\nPHP value\n\n\nPredicate type\n\n\n\n\n\n\n\n\n\n\nnull\n\n\nPredicate\\IsNull\n\n\n\n\n\n\narray\n\n\nPredicate\\In\n\n\n\n\n\n\nstring\n\n\nPredicate\\Operator\n, where the key is the identifier.\n\n\n\n\n\n\n\n\nAs an example:\n\n\n// SELECT \"foo\".* FROM \"foo\" WHERE \"c1\" IS NULL AND \"c2\" IN (?, ?, ?) AND \"c3\" IS NOT NULL\n$select->from('foo')->where([\n    'c1' => null,\n    'c2' => [1, 2, 3],\n    new \\Zend\\Db\\Sql\\Predicate\\IsNotNull('c3'),\n]);\n\n\n\nAs another example of complex queries with nested conditions e.g.\n\n\nSELECT * WHERE (column1 is null or column1 = 2) AND (column2 = 3)\n\n\n\nyou need to use the \nnest()\n and \nunnest()\n methods, as follows:\n\n\n$select->where->nest() // bracket opened\n    ->isNull('column1')\n    ->or\n    ->equalTo('column1', '2')\n    ->unnest();  // bracket closed\n    ->equalTo('column2', '3');\n\n\n\norder()\n\n\n$select = new Select;\n$select->order('id DESC'); // produces 'id' DESC\n\n$select = new Select;\n$select\n    ->order('id DESC')\n    ->order('name ASC, age DESC'); // produces 'id' DESC, 'name' ASC, 'age' DESC\n\n$select = new Select;\n$select->order(['name ASC', 'age DESC']); // produces 'name' ASC, 'age' DESC\n\n\n\nlimit() and offset()\n\n\n$select = new Select;\n$select->limit(5);   // always takes an integer/numeric\n$select->offset(10); // similarly takes an integer/numeric\n\n\n\nInsert\n\n\nThe Insert API:\n\n\nclass Insert implements SqlInterface, PreparableSqlInterface\n{\n    const VALUES_MERGE = 'merge';\n    const VALUES_SET   = 'set';\n\n    public function __construct(string|TableIdentifier $table = null);\n    public function into(string|TableIdentifier $table) : self;\n    public function columns(array $columns) : self;\n    public function values(array $values, string $flag = self::VALUES_SET) : self;\n}\n\n\n\nAs with \nSelect\n, the table may be provided during instantiation or via the\n\ninto()\n method.\n\n\ncolumns()\n\n\n$insert->columns(['foo', 'bar']); // set the valid columns\n\n\n\nvalues()\n\n\n// The default behavior of values is to set the values;\n// successive calls will not preserve values from previous calls.\n$insert->values([\n    'col_1' => 'value1',\n    'col_2' => 'value2',\n]);\n\n\n\n// To merge values with previous calls, provide the appropriate flag:\n$insert->values(['col_2' => 'value2'], $insert::VALUES_MERGE);\n\n\n\nUpdate\n\n\nclass Update\n{\n    const VALUES_MERGE = 'merge';\n    const VALUES_SET   = 'set';\n\n    public $where; // @param Where $where\n    public function __construct(string|TableIdentifier $table = null);\n    public function table(string|TableIdentifier $table) : self;\n    public function set(array $values, string $flag = self::VALUES_SET) : self;\n    public function where(Where|callable|string|array|PredicateInterface $predicate, string $combination = Predicate\\PredicateSet::OP_AND) : self;\n}\n\n\n\nset()\n\n\n$update->set(['foo' => 'bar', 'baz' => 'bax']);\n\n\n\nwhere()\n\n\nSee the \nsection on Where and Having\n.\n\n\nDelete\n\n\nclass Delete\n{\n    public $where; // @param Where $where\n\n    public function __construct(string|TableIdentifier $table = null);\n    public function from(string|TableIdentifier $table);\n    public function where(Where|callable|string|array|PredicateInterface $predicate, string $combination = Predicate\\PredicateSet::OP_AND) : self;\n}\n\n\n\nwhere()\n\n\nSee the \nsection on Where and Having\n.\n\n\nWhere and Having\n\n\nIn the following, we will talk about \nWhere\n; note, however, that \nHaving\n\nutilizes the same API.\n\n\nEffectively, \nWhere\n and \nHaving\n extend from the same base object, a\n\nPredicate\n (and \nPredicateSet\n). All of the parts that make up a WHERE or\nHAVING clause that are AND'ed or OR'd together are called \npredicates\n.  The\nfull set of predicates is called a \nPredicateSet\n. A \nPredicate\n generally\ncontains the values (and identifiers) separate from the fragment they belong to\nuntil the last possible moment when the statement is either prepared\n(parameteritized) or executed. In parameterization, the parameters will be\nreplaced with their proper placeholder (a named or positional parameter), and\nthe values stored inside an \nAdapter\\ParameterContainer\n. When executed, the\nvalues will be interpolated into the fragments they belong to and properly\nquoted.\n\n\nIn the \nWhere\n/\nHaving\n API, a distinction is made between what elements are\nconsidered identifiers (\nTYPE_IDENTIFIER\n) and which are values (\nTYPE_VALUE\n).\nThere is also a special use case type for literal values (\nTYPE_LITERAL\n). All\nelement types are expressed via the \nZend\\Db\\Sql\\ExpressionInterface\n\ninterface.\n\n\n\n\nLiterals\n\n\nIn ZF 2.1, an actual \nLiteral\n type was added. \nZend\\Db\\Sql\n now makes the\ndistinction that literals will not have any parameters that need\ninterpolating, while \nExpression\n objects \nmight\n have parameters that need\ninterpolating. In cases where there are parameters in an \nExpression\n,\n\nZend\\Db\\Sql\\AbstractSql\n will do its best to identify placeholders when the\n\nExpression\n is processed during statement creation. In short, if you don't\nhave parameters, use \nLiteral\n objects.\n\n\n\n\nThe \nWhere\n and \nHaving\n API is that of \nPredicate\n and \nPredicateSet\n:\n\n\n// Where & Having extend Predicate:\nclass Predicate extends PredicateSet\n{\n    public $and;\n    public $or;\n    public $AND;\n    public $OR;\n    public $NEST;\n    public $UNNEST;\n\n    public function nest() : Predicate;\n    public function setUnnest(Predicate $predicate) : void;\n    public function unnest() : Predicate;\n    public function equalTo(\n        int|float|bool|string $left,\n        int|float|bool|string $right,\n        string $leftType = self::TYPE_IDENTIFIER,\n        string $rightType = self::TYPE_VALUE\n    ) : self;\n    public function notEqualTo(\n        int|float|bool|string $left,\n        int|float|bool|string $right,\n        string $leftType = self::TYPE_IDENTIFIER,\n        string $rightType = self::TYPE_VALUE\n    ) : self;\n    public function lessThan(\n        int|float|bool|string $left,\n        int|float|bool|string $right,\n        string $leftType = self::TYPE_IDENTIFIER,\n        string $rightType = self::TYPE_VALUE\n    ) : self;\n    public function greaterThan(\n        int|float|bool|string $left,\n        int|float|bool|string $right,\n        string $leftType = self::TYPE_IDENTIFIER,\n        string $rightType = self::TYPE_VALUE\n    ) : self;\n    public function lessThanOrEqualTo(\n        int|float|bool|string $left,\n        int|float|bool|string $right,\n        string $leftType = self::TYPE_IDENTIFIER,\n        string $rightType = self::TYPE_VALUE\n    ) : self;\n    public function greaterThanOrEqualTo(\n        int|float|bool|string $left,\n        int|float|bool|string $right,\n        string $leftType = self::TYPE_IDENTIFIER,\n        string $rightType = self::TYPE_VALUE\n    ) : self;\n    public function like(string $identifier, string $like) : self;\n    public function notLike(string $identifier, string $notLike) : self;\n    public function literal(string $literal) : self;\n    public function expression(string $expression, array $parameters = null) : self;\n    public function isNull(string $identifier) : self;\n    public function isNotNull(string $identifier) : self;\n    public function in(string $identifier, array $valueSet = []) : self;\n    public function notIn(string $identifier, array $valueSet = []) : self;\n    public function between(\n        string $identifier,\n        int|float|string $minValue,\n        int|float|string $maxValue\n    ) : self;\n    public function notBetween(\n        string $identifier,\n        int|float|string $minValue,\n        int|float|string $maxValue\n    ) : self;\n    public function predicate(PredicateInterface $predicate) : self;\n\n    // Inherited From PredicateSet\n\n    public function addPredicate(PredicateInterface $predicate, $combination = null) : self;\n    public function getPredicates() PredicateInterface[];\n    public function orPredicate(PredicateInterface $predicate) : self;\n    public function andPredicate(PredicateInterface $predicate) : self;\n    public function getExpressionData() : array;\n    public function count() : int;\n}\n\n\n\nEach method in the API will produce a corresponding \nPredicate\n object of a similarly named\ntype, as described below.\n\n\nequalTo(), lessThan(), greaterThan(), lessThanOrEqualTo(), greaterThanOrEqualTo()\n\n\n$where->equalTo('id', 5);\n\n// The above is equivalent to:\n$where->addPredicate(\n    new Predicate\\Operator($left, Operator::OPERATOR_EQUAL_TO, $right, $leftType, $rightType)\n);\n\n\n\nOperators use the following API:\n\n\nclass Operator implements PredicateInterface\n{\n    const OPERATOR_EQUAL_TO                  = '=';\n    const OP_EQ                              = '=';\n    const OPERATOR_NOT_EQUAL_TO              = '!=';\n    const OP_NE                              = '!=';\n    const OPERATOR_LESS_THAN                 = '<';\n    const OP_LT                              = '<';\n    const OPERATOR_LESS_THAN_OR_EQUAL_TO     = '<=';\n    const OP_LTE                             = '<=';\n    const OPERATOR_GREATER_THAN              = '>';\n    const OP_GT                              = '>';\n    const OPERATOR_GREATER_THAN_OR_EQUAL_TO  = '>=';\n    const OP_GTE                             = '>=';\n\n    public function __construct(\n        int|float|bool|string $left = null,\n        string $operator = self::OPERATOR_EQUAL_TO,\n        int|float|bool|string $right = null,\n        string $leftType = self::TYPE_IDENTIFIER,\n        string $rightType = self::TYPE_VALUE\n    );\n    public function setLeft(int|float|bool|string $left);\n    public function getLeft() : int|float|bool|string;\n    public function setLeftType(string $type) : self;\n    public function getLeftType() : string;\n    public function setOperator(string $operator);\n    public function getOperator() : string;\n    public function setRight(int|float|bool|string $value) : self;\n    public function getRight() : int|float|bool|string;\n    public function setRightType(string $type) : self;\n    public function getRightType() : string;\n    public function getExpressionData() : array;\n}\n\n\n\nlike($identifier, $like), notLike($identifier, $notLike)\n\n\n$where->like($identifier, $like):\n\n// The above is equivalent to:\n$where->addPredicate(\n    new Predicate\\Like($identifier, $like)\n);\n\n\n\nThe following is the \nLike\n API:\n\n\nclass Like implements PredicateInterface\n{\n    public function __construct(string $identifier = null, string $like = null);\n    public function setIdentifier(string $identifier) : self;\n    public function getIdentifier() : string;\n    public function setLike(string $like) : self;\n    public function getLike() : string;\n}\n\n\n\nliteral($literal)\n\n\n$where->literal($literal);\n\n// The above is equivalent to:\n$where->addPredicate(\n    new Predicate\\Literal($literal)\n);\n\n\n\nThe following is the \nLiteral\n API:\n\n\nclass Literal implements ExpressionInterface, PredicateInterface\n{\n    const PLACEHOLDER = '?';\n    public function __construct(string $literal = '');\n    public function setLiteral(string $literal) : self;\n    public function getLiteral() : string;\n}\n\n\n\nexpression($expression, $parameter)\n\n\n$where->expression($expression, $parameter);\n\n// The above is equivalent to:\n$where->addPredicate(\n    new Predicate\\Expression($expression, $parameter)\n);\n\n\n\nThe following is the \nExpression\n API:\n\n\nclass Expression implements ExpressionInterface, PredicateInterface\n{\n    const PLACEHOLDER = '?';\n\n    public function __construct(\n        string $expression = null,\n        int|float|bool|string|array $valueParameter = null\n        /* [, $valueParameter, ...  ] */\n    );\n    public function setExpression(string $expression) : self;\n    public function getExpression() : string;\n    public function setParameters(int|float|bool|string|array $parameters) : self;\n    public function getParameters() : array;\n}\n\n\n\nisNull($identifier)\n\n\n$where->isNull($identifier);\n\n// The above is equivalent to:\n$where->addPredicate(\n    new Predicate\\IsNull($identifier)\n);\n\n\n\nThe following is the \nIsNull\n API:\n\n\nclass IsNull implements PredicateInterface\n{\n    public function __construct(string $identifier = null);\n    public function setIdentifier(string $identifier) : self;\n    public function getIdentifier() : string;\n}\n\n\n\nisNotNull($identifier)\n\n\n$where->isNotNull($identifier);\n\n// The above is equivalent to:\n$where->addPredicate(\n    new Predicate\\IsNotNull($identifier)\n);\n\n\n\nThe following is the \nIsNotNull\n API:\n\n\nclass IsNotNull implements PredicateInterface\n{\n    public function __construct(string $identifier = null);\n    public function setIdentifier(string $identifier) : self;\n    public function getIdentifier() : string;\n}\n\n\n\nin($identifier, $valueSet), notIn($identifier, $valueSet)\n\n\n$where->in($identifier, $valueSet);\n\n// The above is equivalent to:\n$where->addPredicate(\n    new Predicate\\In($identifier, $valueSet)\n);\n\n\n\nThe following is the \nIn\n API:\n\n\nclass In implements PredicateInterface\n{\n    public function __construct(\n        string|array $identifier = null,\n        array|Select $valueSet = null\n    );\n    public function setIdentifier(string|array $identifier) : self;\n    public function getIdentifier() : string|array;\n    public function setValueSet(array|Select $valueSet) : self;\n    public function getValueSet() : array|Select;\n}\n\n\n\nbetween($identifier, $minValue, $maxValue), notBetween($identifier, $minValue, $maxValue)\n\n\n$where->between($identifier, $minValue, $maxValue);\n\n// The above is equivalent to:\n$where->addPredicate(\n    new Predicate\\Between($identifier, $minValue, $maxValue)\n);\n\n\n\nThe following is the \nBetween\n API:\n\n\nclass Between implements PredicateInterface\n{\n    public function __construct(\n        string $identifier = null,\n        int|float|string $minValue = null,\n        int|float|string $maxValue = null\n    );\n    public function setIdentifier(string $identifier) : self;\n    public function getIdentifier() : string;\n    public function setMinValue(int|float|string $minValue) : self;\n    public function getMinValue() : int|float|string;\n    public function setMaxValue(int|float|string $maxValue) : self;\n    public function getMaxValue() : int|float|string;\n    public function setSpecification(string $specification);\n}",
            "title": "SQL Abstraction"
        },
        {
            "location": "/sql/#sql-abstraction",
            "text": "Zend\\Db\\Sql  is a SQL abstraction layer for building platform-specific SQL\nqueries via an object-oriented API. The end result of a  Zend\\Db\\Sql  object\nwill be to either produce a  Statement  and  ParameterContainer  that\nrepresents the target query, or a full string that can be directly executed\nagainst the database platform. To achieve this,  Zend\\Db\\Sql  objects require a Zend\\Db\\Adapter\\Adapter  object in order to produce the desired results.",
            "title": "SQL Abstraction"
        },
        {
            "location": "/sql/#quick-start",
            "text": "There are four primary tasks associated with interacting with a database\ndefined by Data Manipulation Language (DML): selecting, inserting, updating,\nand deleting. As such, there are four primary classes that developers can\ninteract with in order to build queries in the  Zend\\Db\\Sql  namespace: Select ,  Insert ,  Update , and  Delete .  Since these four tasks are so closely related and generally used together\nwithin the same application, the  Zend\\Db\\Sql\\Sql  class helps you create them\nand produce the result you are attempting to achieve.  use Zend\\Db\\Sql\\Sql;\n\n$sql    = new Sql($adapter);\n$select = $sql->select(); // returns a Zend\\Db\\Sql\\Select instance\n$insert = $sql->insert(); // returns a Zend\\Db\\Sql\\Insert instance\n$update = $sql->update(); // returns a Zend\\Db\\Sql\\Update instance\n$delete = $sql->delete(); // returns a Zend\\Db\\Sql\\Delete instance  As a developer, you can now interact with these objects, as described in the\nsections below, to customize each query. Once they have been populated with\nvalues, they are ready to either be prepared or executed.  To prepare (using a Select object):  use Zend\\Db\\Sql\\Sql;\n\n$sql    = new Sql($adapter);\n$select = $sql->select();\n$select->from('foo');\n$select->where(['id' => 2]);\n\n$statement = $sql->prepareStatementForSqlObject($select);\n$results = $statement->execute();  To execute (using a Select object)  use Zend\\Db\\Sql\\Sql;\n\n$sql    = new Sql($adapter);\n$select = $sql->select();\n$select->from('foo');\n$select->where(['id' => 2]);\n\n$selectString = $sql->buildSqlString($select);\n$results = $adapter->query($selectString, $adapter::QUERY_MODE_EXECUTE);  Zend\\\\Db\\\\Sql\\\\Sql  objects can also be bound to a particular table so that in\nobtaining a  Select ,  Insert ,  Update , or  Delete  instance, the object will be\nseeded with the table:  use Zend\\Db\\Sql\\Sql;\n\n$sql    = new Sql($adapter, 'foo');\n$select = $sql->select();\n$select->where(['id' => 2]); // $select already has from('foo') applied",
            "title": "Quick start"
        },
        {
            "location": "/sql/#common-interfaces-for-sql-implementations",
            "text": "Each of these objects implements the following two interfaces:  interface PreparableSqlInterface\n{\n     public function prepareStatement(Adapter $adapter, StatementInterface $statement) : void;\n}\n\ninterface SqlInterface\n{\n     public function getSqlString(PlatformInterface $adapterPlatform = null) : string;\n}  Use these functions to produce either (a) a prepared statement, or (b) a string\nto execute.",
            "title": "Common interfaces for SQL implementations"
        },
        {
            "location": "/sql/#select",
            "text": "Zend\\Db\\Sql\\Select  presents a unified API for building platform-specific SQL\nSELECT queries. Instances may be created and consumed without Zend\\Db\\Sql\\Sql :  use Zend\\Db\\Sql\\Select;\n\n$select = new Select();\n// or, to produce a $select bound to a specific table\n$select = new Select('foo');  If a table is provided to the  Select  object, then  from()  cannot be called\nlater to change the name of the table.  Once you have a valid  Select  object, the following API can be used to further\nspecify various select statement parts:  class Select extends AbstractSql implements SqlInterface, PreparableSqlInterface\n{\n    const JOIN_INNER = 'inner';\n    const JOIN_OUTER = 'outer';\n    const JOIN_LEFT = 'left';\n    const JOIN_RIGHT = 'right';\n    const SQL_STAR = '*';\n    const ORDER_ASCENDING = 'ASC';\n    const ORDER_DESCENDING = 'DESC';\n\n    public $where; // @param Where $where\n\n    public function __construct(string|array|TableIdentifier $table = null);\n    public function from(string|array|TableIdentifier $table) : self;\n    public function columns(array $columns, bool $prefixColumnsWithTable = true) : self;\n    public function join(string|array $name, string $on, string|array $columns = self::SQL_STAR, string $type = self::JOIN_INNER) : self;\n    public function where(Where|callable|string|array|PredicateInterface $predicate, string $combination = Predicate\\PredicateSet::OP_AND) : self;\n    public function group(string|array $group);\n    public function having(Having|callable|string|array $predicate, string $combination = Predicate\\PredicateSet::OP_AND) : self;\n    public function order(string|array $order) : self;\n    public function limit(int $limit) : self;\n    public function offset(int $offset) : self;\n}",
            "title": "Select"
        },
        {
            "location": "/sql/#from",
            "text": "// As a string:\n$select->from('foo');\n\n// As an array to specify an alias\n// (produces SELECT \"t\".* FROM \"table\" AS \"t\")\n$select->from(['t' => 'table']);\n\n// Using a Sql\\TableIdentifier:\n// (same output as above)\n$select->from(['t' => new TableIdentifier('table')]);",
            "title": "from()"
        },
        {
            "location": "/sql/#columns",
            "text": "// As an array of names\n$select->columns(['foo', 'bar']);\n\n// As an associative array with aliases as the keys\n// (produces 'bar' AS 'foo', 'bax' AS 'baz')\n$select->columns(['foo' => 'bar', 'baz' => 'bax']);",
            "title": "columns()"
        },
        {
            "location": "/sql/#join",
            "text": "$select->join(\n    'foo',              // table name\n    'id = bar.id',      // expression to join on (will be quoted by platform object before insertion),\n    ['bar', 'baz'],     // (optional) list of columns, same requirements as columns() above\n    $select::JOIN_OUTER // (optional), one of inner, outer, left, right also represented by constants in the API\n);\n\n$select\n    ->from(['f' => 'foo'])     // base table\n    ->join(\n        ['b' => 'bar'],        // join table with alias\n        'f.foo_id = b.foo_id'  // join expression\n    );",
            "title": "join()"
        },
        {
            "location": "/sql/#where-having",
            "text": "Zend\\Db\\Sql\\Select  provides bit of flexibility as it regards to what kind of\nparameters are acceptable when calling  where()  or  having() . The method\nsignature is listed as:  /**\n * Create where clause\n *\n * @param  Where|callable|string|array $predicate\n * @param  string $combination One of the OP_* constants from Predicate\\PredicateSet\n * @return Select\n */\npublic function where($predicate, $combination = Predicate\\PredicateSet::OP_AND);  If you provide a  Zend\\Db\\Sql\\Where  instance to  where()  or a Zend\\Db\\Sql\\Having  instance to  having() , any previous internal instances\nwill be replaced completely. When either instance is processed, this object will\nbe iterated to produce the WHERE or HAVING section of the SELECT statement.  If you provide a PHP callable to  where()  or  having() , this function will be\ncalled with the  Select 's  Where / Having  instance as the only parameter.\nThis enables code like the following:  $select->where(function (Where $where) {\n    $where->like('username', 'ralph%');\n});  If you provide a  string , this string will be used to create a Zend\\Db\\Sql\\Predicate\\Expression  instance, and its contents will be applied\nas-is, with no quoting:  // SELECT \"foo\".* FROM \"foo\" WHERE x = 5\n$select->from('foo')->where('x = 5');  If you provide an array with integer indices, the value can be one of:   a string; this will be used to build a  Predicate\\Expression .  any object implementing  Predicate\\PredicateInterface .   In either case, the instances are pushed onto the  Where  stack with the $combination  provided (defaulting to  AND ).  As an example:  // SELECT \"foo\".* FROM \"foo\" WHERE x = 5 AND y = z\n$select->from('foo')->where(['x = 5', 'y = z']);  If you provide an associative array with string keys, any value with a string\nkey will be cast as follows:     PHP value  Predicate type      null  Predicate\\IsNull    array  Predicate\\In    string  Predicate\\Operator , where the key is the identifier.     As an example:  // SELECT \"foo\".* FROM \"foo\" WHERE \"c1\" IS NULL AND \"c2\" IN (?, ?, ?) AND \"c3\" IS NOT NULL\n$select->from('foo')->where([\n    'c1' => null,\n    'c2' => [1, 2, 3],\n    new \\Zend\\Db\\Sql\\Predicate\\IsNotNull('c3'),\n]);  As another example of complex queries with nested conditions e.g.  SELECT * WHERE (column1 is null or column1 = 2) AND (column2 = 3)  you need to use the  nest()  and  unnest()  methods, as follows:  $select->where->nest() // bracket opened\n    ->isNull('column1')\n    ->or\n    ->equalTo('column1', '2')\n    ->unnest();  // bracket closed\n    ->equalTo('column2', '3');",
            "title": "where(), having()"
        },
        {
            "location": "/sql/#order",
            "text": "$select = new Select;\n$select->order('id DESC'); // produces 'id' DESC\n\n$select = new Select;\n$select\n    ->order('id DESC')\n    ->order('name ASC, age DESC'); // produces 'id' DESC, 'name' ASC, 'age' DESC\n\n$select = new Select;\n$select->order(['name ASC', 'age DESC']); // produces 'name' ASC, 'age' DESC",
            "title": "order()"
        },
        {
            "location": "/sql/#limit-and-offset",
            "text": "$select = new Select;\n$select->limit(5);   // always takes an integer/numeric\n$select->offset(10); // similarly takes an integer/numeric",
            "title": "limit() and offset()"
        },
        {
            "location": "/sql/#insert",
            "text": "The Insert API:  class Insert implements SqlInterface, PreparableSqlInterface\n{\n    const VALUES_MERGE = 'merge';\n    const VALUES_SET   = 'set';\n\n    public function __construct(string|TableIdentifier $table = null);\n    public function into(string|TableIdentifier $table) : self;\n    public function columns(array $columns) : self;\n    public function values(array $values, string $flag = self::VALUES_SET) : self;\n}  As with  Select , the table may be provided during instantiation or via the into()  method.",
            "title": "Insert"
        },
        {
            "location": "/sql/#columns_1",
            "text": "$insert->columns(['foo', 'bar']); // set the valid columns",
            "title": "columns()"
        },
        {
            "location": "/sql/#values",
            "text": "// The default behavior of values is to set the values;\n// successive calls will not preserve values from previous calls.\n$insert->values([\n    'col_1' => 'value1',\n    'col_2' => 'value2',\n]);  // To merge values with previous calls, provide the appropriate flag:\n$insert->values(['col_2' => 'value2'], $insert::VALUES_MERGE);",
            "title": "values()"
        },
        {
            "location": "/sql/#update",
            "text": "class Update\n{\n    const VALUES_MERGE = 'merge';\n    const VALUES_SET   = 'set';\n\n    public $where; // @param Where $where\n    public function __construct(string|TableIdentifier $table = null);\n    public function table(string|TableIdentifier $table) : self;\n    public function set(array $values, string $flag = self::VALUES_SET) : self;\n    public function where(Where|callable|string|array|PredicateInterface $predicate, string $combination = Predicate\\PredicateSet::OP_AND) : self;\n}",
            "title": "Update"
        },
        {
            "location": "/sql/#set",
            "text": "$update->set(['foo' => 'bar', 'baz' => 'bax']);",
            "title": "set()"
        },
        {
            "location": "/sql/#where",
            "text": "See the  section on Where and Having .",
            "title": "where()"
        },
        {
            "location": "/sql/#delete",
            "text": "class Delete\n{\n    public $where; // @param Where $where\n\n    public function __construct(string|TableIdentifier $table = null);\n    public function from(string|TableIdentifier $table);\n    public function where(Where|callable|string|array|PredicateInterface $predicate, string $combination = Predicate\\PredicateSet::OP_AND) : self;\n}",
            "title": "Delete"
        },
        {
            "location": "/sql/#where_1",
            "text": "See the  section on Where and Having .",
            "title": "where()"
        },
        {
            "location": "/sql/#where-and-having",
            "text": "In the following, we will talk about  Where ; note, however, that  Having \nutilizes the same API.  Effectively,  Where  and  Having  extend from the same base object, a Predicate  (and  PredicateSet ). All of the parts that make up a WHERE or\nHAVING clause that are AND'ed or OR'd together are called  predicates .  The\nfull set of predicates is called a  PredicateSet . A  Predicate  generally\ncontains the values (and identifiers) separate from the fragment they belong to\nuntil the last possible moment when the statement is either prepared\n(parameteritized) or executed. In parameterization, the parameters will be\nreplaced with their proper placeholder (a named or positional parameter), and\nthe values stored inside an  Adapter\\ParameterContainer . When executed, the\nvalues will be interpolated into the fragments they belong to and properly\nquoted.  In the  Where / Having  API, a distinction is made between what elements are\nconsidered identifiers ( TYPE_IDENTIFIER ) and which are values ( TYPE_VALUE ).\nThere is also a special use case type for literal values ( TYPE_LITERAL ). All\nelement types are expressed via the  Zend\\Db\\Sql\\ExpressionInterface \ninterface.",
            "title": "Where and Having"
        },
        {
            "location": "/sql/#literals",
            "text": "In ZF 2.1, an actual  Literal  type was added.  Zend\\Db\\Sql  now makes the\ndistinction that literals will not have any parameters that need\ninterpolating, while  Expression  objects  might  have parameters that need\ninterpolating. In cases where there are parameters in an  Expression , Zend\\Db\\Sql\\AbstractSql  will do its best to identify placeholders when the Expression  is processed during statement creation. In short, if you don't\nhave parameters, use  Literal  objects.   The  Where  and  Having  API is that of  Predicate  and  PredicateSet :  // Where & Having extend Predicate:\nclass Predicate extends PredicateSet\n{\n    public $and;\n    public $or;\n    public $AND;\n    public $OR;\n    public $NEST;\n    public $UNNEST;\n\n    public function nest() : Predicate;\n    public function setUnnest(Predicate $predicate) : void;\n    public function unnest() : Predicate;\n    public function equalTo(\n        int|float|bool|string $left,\n        int|float|bool|string $right,\n        string $leftType = self::TYPE_IDENTIFIER,\n        string $rightType = self::TYPE_VALUE\n    ) : self;\n    public function notEqualTo(\n        int|float|bool|string $left,\n        int|float|bool|string $right,\n        string $leftType = self::TYPE_IDENTIFIER,\n        string $rightType = self::TYPE_VALUE\n    ) : self;\n    public function lessThan(\n        int|float|bool|string $left,\n        int|float|bool|string $right,\n        string $leftType = self::TYPE_IDENTIFIER,\n        string $rightType = self::TYPE_VALUE\n    ) : self;\n    public function greaterThan(\n        int|float|bool|string $left,\n        int|float|bool|string $right,\n        string $leftType = self::TYPE_IDENTIFIER,\n        string $rightType = self::TYPE_VALUE\n    ) : self;\n    public function lessThanOrEqualTo(\n        int|float|bool|string $left,\n        int|float|bool|string $right,\n        string $leftType = self::TYPE_IDENTIFIER,\n        string $rightType = self::TYPE_VALUE\n    ) : self;\n    public function greaterThanOrEqualTo(\n        int|float|bool|string $left,\n        int|float|bool|string $right,\n        string $leftType = self::TYPE_IDENTIFIER,\n        string $rightType = self::TYPE_VALUE\n    ) : self;\n    public function like(string $identifier, string $like) : self;\n    public function notLike(string $identifier, string $notLike) : self;\n    public function literal(string $literal) : self;\n    public function expression(string $expression, array $parameters = null) : self;\n    public function isNull(string $identifier) : self;\n    public function isNotNull(string $identifier) : self;\n    public function in(string $identifier, array $valueSet = []) : self;\n    public function notIn(string $identifier, array $valueSet = []) : self;\n    public function between(\n        string $identifier,\n        int|float|string $minValue,\n        int|float|string $maxValue\n    ) : self;\n    public function notBetween(\n        string $identifier,\n        int|float|string $minValue,\n        int|float|string $maxValue\n    ) : self;\n    public function predicate(PredicateInterface $predicate) : self;\n\n    // Inherited From PredicateSet\n\n    public function addPredicate(PredicateInterface $predicate, $combination = null) : self;\n    public function getPredicates() PredicateInterface[];\n    public function orPredicate(PredicateInterface $predicate) : self;\n    public function andPredicate(PredicateInterface $predicate) : self;\n    public function getExpressionData() : array;\n    public function count() : int;\n}  Each method in the API will produce a corresponding  Predicate  object of a similarly named\ntype, as described below.",
            "title": "Literals"
        },
        {
            "location": "/sql/#equalto-lessthan-greaterthan-lessthanorequalto-greaterthanorequalto",
            "text": "$where->equalTo('id', 5);\n\n// The above is equivalent to:\n$where->addPredicate(\n    new Predicate\\Operator($left, Operator::OPERATOR_EQUAL_TO, $right, $leftType, $rightType)\n);  Operators use the following API:  class Operator implements PredicateInterface\n{\n    const OPERATOR_EQUAL_TO                  = '=';\n    const OP_EQ                              = '=';\n    const OPERATOR_NOT_EQUAL_TO              = '!=';\n    const OP_NE                              = '!=';\n    const OPERATOR_LESS_THAN                 = '<';\n    const OP_LT                              = '<';\n    const OPERATOR_LESS_THAN_OR_EQUAL_TO     = '<=';\n    const OP_LTE                             = '<=';\n    const OPERATOR_GREATER_THAN              = '>';\n    const OP_GT                              = '>';\n    const OPERATOR_GREATER_THAN_OR_EQUAL_TO  = '>=';\n    const OP_GTE                             = '>=';\n\n    public function __construct(\n        int|float|bool|string $left = null,\n        string $operator = self::OPERATOR_EQUAL_TO,\n        int|float|bool|string $right = null,\n        string $leftType = self::TYPE_IDENTIFIER,\n        string $rightType = self::TYPE_VALUE\n    );\n    public function setLeft(int|float|bool|string $left);\n    public function getLeft() : int|float|bool|string;\n    public function setLeftType(string $type) : self;\n    public function getLeftType() : string;\n    public function setOperator(string $operator);\n    public function getOperator() : string;\n    public function setRight(int|float|bool|string $value) : self;\n    public function getRight() : int|float|bool|string;\n    public function setRightType(string $type) : self;\n    public function getRightType() : string;\n    public function getExpressionData() : array;\n}",
            "title": "equalTo(), lessThan(), greaterThan(), lessThanOrEqualTo(), greaterThanOrEqualTo()"
        },
        {
            "location": "/sql/#likeidentifier-like-notlikeidentifier-notlike",
            "text": "$where->like($identifier, $like):\n\n// The above is equivalent to:\n$where->addPredicate(\n    new Predicate\\Like($identifier, $like)\n);  The following is the  Like  API:  class Like implements PredicateInterface\n{\n    public function __construct(string $identifier = null, string $like = null);\n    public function setIdentifier(string $identifier) : self;\n    public function getIdentifier() : string;\n    public function setLike(string $like) : self;\n    public function getLike() : string;\n}",
            "title": "like($identifier, $like), notLike($identifier, $notLike)"
        },
        {
            "location": "/sql/#literalliteral",
            "text": "$where->literal($literal);\n\n// The above is equivalent to:\n$where->addPredicate(\n    new Predicate\\Literal($literal)\n);  The following is the  Literal  API:  class Literal implements ExpressionInterface, PredicateInterface\n{\n    const PLACEHOLDER = '?';\n    public function __construct(string $literal = '');\n    public function setLiteral(string $literal) : self;\n    public function getLiteral() : string;\n}",
            "title": "literal($literal)"
        },
        {
            "location": "/sql/#expressionexpression-parameter",
            "text": "$where->expression($expression, $parameter);\n\n// The above is equivalent to:\n$where->addPredicate(\n    new Predicate\\Expression($expression, $parameter)\n);  The following is the  Expression  API:  class Expression implements ExpressionInterface, PredicateInterface\n{\n    const PLACEHOLDER = '?';\n\n    public function __construct(\n        string $expression = null,\n        int|float|bool|string|array $valueParameter = null\n        /* [, $valueParameter, ...  ] */\n    );\n    public function setExpression(string $expression) : self;\n    public function getExpression() : string;\n    public function setParameters(int|float|bool|string|array $parameters) : self;\n    public function getParameters() : array;\n}",
            "title": "expression($expression, $parameter)"
        },
        {
            "location": "/sql/#isnullidentifier",
            "text": "$where->isNull($identifier);\n\n// The above is equivalent to:\n$where->addPredicate(\n    new Predicate\\IsNull($identifier)\n);  The following is the  IsNull  API:  class IsNull implements PredicateInterface\n{\n    public function __construct(string $identifier = null);\n    public function setIdentifier(string $identifier) : self;\n    public function getIdentifier() : string;\n}",
            "title": "isNull($identifier)"
        },
        {
            "location": "/sql/#isnotnullidentifier",
            "text": "$where->isNotNull($identifier);\n\n// The above is equivalent to:\n$where->addPredicate(\n    new Predicate\\IsNotNull($identifier)\n);  The following is the  IsNotNull  API:  class IsNotNull implements PredicateInterface\n{\n    public function __construct(string $identifier = null);\n    public function setIdentifier(string $identifier) : self;\n    public function getIdentifier() : string;\n}",
            "title": "isNotNull($identifier)"
        },
        {
            "location": "/sql/#inidentifier-valueset-notinidentifier-valueset",
            "text": "$where->in($identifier, $valueSet);\n\n// The above is equivalent to:\n$where->addPredicate(\n    new Predicate\\In($identifier, $valueSet)\n);  The following is the  In  API:  class In implements PredicateInterface\n{\n    public function __construct(\n        string|array $identifier = null,\n        array|Select $valueSet = null\n    );\n    public function setIdentifier(string|array $identifier) : self;\n    public function getIdentifier() : string|array;\n    public function setValueSet(array|Select $valueSet) : self;\n    public function getValueSet() : array|Select;\n}",
            "title": "in($identifier, $valueSet), notIn($identifier, $valueSet)"
        },
        {
            "location": "/sql/#betweenidentifier-minvalue-maxvalue-notbetweenidentifier-minvalue-maxvalue",
            "text": "$where->between($identifier, $minValue, $maxValue);\n\n// The above is equivalent to:\n$where->addPredicate(\n    new Predicate\\Between($identifier, $minValue, $maxValue)\n);  The following is the  Between  API:  class Between implements PredicateInterface\n{\n    public function __construct(\n        string $identifier = null,\n        int|float|string $minValue = null,\n        int|float|string $maxValue = null\n    );\n    public function setIdentifier(string $identifier) : self;\n    public function getIdentifier() : string;\n    public function setMinValue(int|float|string $minValue) : self;\n    public function getMinValue() : int|float|string;\n    public function setMaxValue(int|float|string $maxValue) : self;\n    public function getMaxValue() : int|float|string;\n    public function setSpecification(string $specification);\n}",
            "title": "between($identifier, $minValue, $maxValue), notBetween($identifier, $minValue, $maxValue)"
        },
        {
            "location": "/sql-ddl/",
            "text": "DDL Abstraction\n\n\nZend\\Db\\Sql\\Ddl\n is a sub-component of \nZend\\Db\\Sql\n allowing creation of DDL\n(Data Definition Language) SQL statements. When combined with a platform\nspecific \nZend\\Db\\Sql\\Sql\n object, DDL objects are capable of producing\nplatform-specific \nCREATE TABLE\n statements, with specialized data types,\nconstraints, and indexes for a database/schema.\n\n\nThe following platforms have platform specializations for DDL:\n\n\n\n\nMySQL\n\n\nAll databases compatible with ANSI SQL92\n\n\n\n\nCreating Tables\n\n\nLike \nZend\\Db\\Sql\n objects, each statement type is represented by a class. For\nexample, \nCREATE TABLE\n is modeled by the \nCreateTable\n class; this is likewise\nthe same for \nALTER TABLE\n (as \nAlterTable\n), and \nDROP TABLE\n (as\n\nDropTable\n). You can create instances using a number of approaches:\n\n\nuse Zend\\Db\\Sql\\Ddl;\n\n$table = new Ddl\\CreateTable();\n\n// With a table name:\n$table = new Ddl\\CreateTable('bar');\n\n// Optionally, as a temporary table:\n$table = new Ddl\\CreateTable('bar', true);\n\n\n\nYou can also set the table after instantiation:\n\n\n$table->setTable('bar');\n\n\n\nCurrently, columns are added by creating a column object (described in the\n\ndata type table below\n):\n\n\nuse Zend\\Db\\Sql\\Ddl\\Column;\n\n$table->addColumn(new Column\\Integer('id'));\n$table->addColumn(new Column\\Varchar('name', 255));\n\n\n\nBeyond adding columns to a table, you may also add constraints:\n\n\nuse Zend\\Db\\Sql\\Ddl\\Constraint;\n\n$table->addConstraint(new Constraint\\PrimaryKey('id'));\n$table->addConstraint(\n    new Constraint\\UniqueKey(['name', 'foo'], 'my_unique_key')\n);\n\n\n\nAltering Tables\n\n\nSimilar to \nCreateTable\n, you may also use \nAlterTable\n instances:\n\n\nuse Zend\\Db\\Sql\\Ddl;\n\n$table = new Ddl\\AlterTable();\n\n// With a table name:\n$table = new Ddl\\AlterTable('bar');\n\n// Optionally, as a temporary table:\n$table = new Ddl\\AlterTable('bar', true);\n\n\n\nThe primary difference between a \nCreateTable\n and \nAlterTable\n is that the\n\nAlterTable\n takes into account that the table and its assets already exist.\nTherefore, while you still have \naddColumn()\n and \naddConstraint()\n, you will\nalso have the ability to \nalter\n existing columns:\n\n\nuse Zend\\Db\\Sql\\Ddl\\Column;\n\n$table->changeColumn('name', Column\\Varchar('new_name', 50));\n\n\n\nYou may also \ndrop\n existing columns or constraints:\n\n\n$table->dropColumn('foo');\n$table->dropConstraint('my_index');\n\n\n\nDropping Tables\n\n\nTo drop a table, create a \nDropTable\n instance:\n\n\n$drop = new Ddl\\DropTable('bar');\n\n\n\nExecuting DDL Statements\n\n\nAfter a DDL statement object has been created and configured, at some point you\nwill need to execute the statement. This requires an \nAdapter\n instance and a\nproperly seeded \nSql\n instance.\n\n\nThe workflow looks something like this, with \n$ddl\n being a \nCreateTable\n,\n\nAlterTable\n, or \nDropTable\n instance:\n\n\nuse Zend\\Db\\Sql\\Sql;\n\n// Existence of $adapter is assumed.\n$sql = new Sql($adapter);\n\n$adapter->query(\n    $sql->getSqlStringForSqlObject($ddl),\n    $adapter::QUERY_MODE_EXECUTE\n);\n\n\n\nBy passing the \n$ddl\n object through the \n$sql\n instance's\n\ngetSqlStringForSqlObject()\n method, we ensure that any platform specific\nspecializations/modifications are utilized to create a platform specific SQL\nstatement.\n\n\nNext, using the constant \nZend\\Db\\Adapter\\Adapter::QUERY_MODE_EXECUTE\n ensures\nthat the SQL statement is not prepared, as most DDL statements on most\nplatforms cannot be prepared, only executed.\n\n\nCurrently Supported Data Types\n\n\nThese types exist in the \nZend\\Db\\Sql\\Ddl\\Column\n namespace. Data types must\nimplement \nZend\\Db\\Sql\\Ddl\\Column\\ColumnInterface\n.\n\n\nIn alphabetical order:\n\n\n\n\n\n\n\n\nType\n\n\nArguments For Construction\n\n\n\n\n\n\n\n\n\n\nBigInteger\n\n\n$name\n, \n$nullable = false\n, \n$default = null\n, \narray $options = array()\n\n\n\n\n\n\nBlob\n\n\n$name\n, \n$length\n, \nnullable = false\n, \n$default = null\n, \narray $options = array()\n\n\n\n\n\n\nBoolean\n\n\n$name\n\n\n\n\n\n\nChar\n\n\n$name\n, \nlength\n\n\n\n\n\n\nColumn (generic)\n\n\n$name = null\n\n\n\n\n\n\nDate\n\n\n$name\n\n\n\n\n\n\nDecimal\n\n\n$name\n, \n$precision\n, \n$scale = null\n\n\n\n\n\n\nFloat\n\n\n$name\n, \n$digits\n, \n$decimal\n (Note: this class is deprecated as of 2.4.0; use Floating instead)\n\n\n\n\n\n\nFloating\n\n\n$name\n, \n$digits\n, \n$decimal\n\n\n\n\n\n\nInteger\n\n\n$name\n, \n$nullable = false\n, \ndefault = null\n, \narray $options = array()\n\n\n\n\n\n\nText\n\n\n$name\n, \n$length\n, \nnullable = false\n, \n$default = null\n, \narray $options = array()\n\n\n\n\n\n\nTime\n\n\n$name\n\n\n\n\n\n\nVarchar\n\n\n$name\n, \n$length\n\n\n\n\n\n\n\n\nEach of the above types can be utilized in any place that accepts a \nColumn\\ColumnInterface\n\ninstance. Currently, this is primarily in \nCreateTable::addColumn()\n and \nAlterTable\n's\n\naddColumn()\n and \nchangeColumn()\n methods.\n\n\nCurrently Supported Constraint Types\n\n\nThese types exist in the \nZend\\Db\\Sql\\Ddl\\Constraint\n namespace. Data types\nmust implement \nZend\\Db\\Sql\\Ddl\\Constraint\\ConstraintInterface\n.\n\n\nIn alphabetical order:\n\n\n\n\n\n\n\n\nType\n\n\nArguments For Construction\n\n\n\n\n\n\n\n\n\n\nCheck\n\n\n$expression\n, \n$name\n\n\n\n\n\n\nForeignKey\n\n\n$name\n, \n$column\n, \n$referenceTable\n, \n$referenceColumn\n, \n$onDeleteRule = null\n, \n$onUpdateRule = null\n\n\n\n\n\n\nPrimaryKey\n\n\n$columns\n\n\n\n\n\n\nUniqueKey\n\n\n$column\n, \n$name = null\n\n\n\n\n\n\n\n\nEach of the above types can be utilized in any place that accepts a\n\nColumn\\ConstraintInterface\n instance. Currently, this is primarily in\n\nCreateTable::addConstraint()\n and \nAlterTable::addConstraint()\n.",
            "title": "DDL Abstraction"
        },
        {
            "location": "/sql-ddl/#ddl-abstraction",
            "text": "Zend\\Db\\Sql\\Ddl  is a sub-component of  Zend\\Db\\Sql  allowing creation of DDL\n(Data Definition Language) SQL statements. When combined with a platform\nspecific  Zend\\Db\\Sql\\Sql  object, DDL objects are capable of producing\nplatform-specific  CREATE TABLE  statements, with specialized data types,\nconstraints, and indexes for a database/schema.  The following platforms have platform specializations for DDL:   MySQL  All databases compatible with ANSI SQL92",
            "title": "DDL Abstraction"
        },
        {
            "location": "/sql-ddl/#creating-tables",
            "text": "Like  Zend\\Db\\Sql  objects, each statement type is represented by a class. For\nexample,  CREATE TABLE  is modeled by the  CreateTable  class; this is likewise\nthe same for  ALTER TABLE  (as  AlterTable ), and  DROP TABLE  (as DropTable ). You can create instances using a number of approaches:  use Zend\\Db\\Sql\\Ddl;\n\n$table = new Ddl\\CreateTable();\n\n// With a table name:\n$table = new Ddl\\CreateTable('bar');\n\n// Optionally, as a temporary table:\n$table = new Ddl\\CreateTable('bar', true);  You can also set the table after instantiation:  $table->setTable('bar');  Currently, columns are added by creating a column object (described in the data type table below ):  use Zend\\Db\\Sql\\Ddl\\Column;\n\n$table->addColumn(new Column\\Integer('id'));\n$table->addColumn(new Column\\Varchar('name', 255));  Beyond adding columns to a table, you may also add constraints:  use Zend\\Db\\Sql\\Ddl\\Constraint;\n\n$table->addConstraint(new Constraint\\PrimaryKey('id'));\n$table->addConstraint(\n    new Constraint\\UniqueKey(['name', 'foo'], 'my_unique_key')\n);",
            "title": "Creating Tables"
        },
        {
            "location": "/sql-ddl/#altering-tables",
            "text": "Similar to  CreateTable , you may also use  AlterTable  instances:  use Zend\\Db\\Sql\\Ddl;\n\n$table = new Ddl\\AlterTable();\n\n// With a table name:\n$table = new Ddl\\AlterTable('bar');\n\n// Optionally, as a temporary table:\n$table = new Ddl\\AlterTable('bar', true);  The primary difference between a  CreateTable  and  AlterTable  is that the AlterTable  takes into account that the table and its assets already exist.\nTherefore, while you still have  addColumn()  and  addConstraint() , you will\nalso have the ability to  alter  existing columns:  use Zend\\Db\\Sql\\Ddl\\Column;\n\n$table->changeColumn('name', Column\\Varchar('new_name', 50));  You may also  drop  existing columns or constraints:  $table->dropColumn('foo');\n$table->dropConstraint('my_index');",
            "title": "Altering Tables"
        },
        {
            "location": "/sql-ddl/#dropping-tables",
            "text": "To drop a table, create a  DropTable  instance:  $drop = new Ddl\\DropTable('bar');",
            "title": "Dropping Tables"
        },
        {
            "location": "/sql-ddl/#executing-ddl-statements",
            "text": "After a DDL statement object has been created and configured, at some point you\nwill need to execute the statement. This requires an  Adapter  instance and a\nproperly seeded  Sql  instance.  The workflow looks something like this, with  $ddl  being a  CreateTable , AlterTable , or  DropTable  instance:  use Zend\\Db\\Sql\\Sql;\n\n// Existence of $adapter is assumed.\n$sql = new Sql($adapter);\n\n$adapter->query(\n    $sql->getSqlStringForSqlObject($ddl),\n    $adapter::QUERY_MODE_EXECUTE\n);  By passing the  $ddl  object through the  $sql  instance's getSqlStringForSqlObject()  method, we ensure that any platform specific\nspecializations/modifications are utilized to create a platform specific SQL\nstatement.  Next, using the constant  Zend\\Db\\Adapter\\Adapter::QUERY_MODE_EXECUTE  ensures\nthat the SQL statement is not prepared, as most DDL statements on most\nplatforms cannot be prepared, only executed.",
            "title": "Executing DDL Statements"
        },
        {
            "location": "/sql-ddl/#currently-supported-data-types",
            "text": "These types exist in the  Zend\\Db\\Sql\\Ddl\\Column  namespace. Data types must\nimplement  Zend\\Db\\Sql\\Ddl\\Column\\ColumnInterface .  In alphabetical order:     Type  Arguments For Construction      BigInteger  $name ,  $nullable = false ,  $default = null ,  array $options = array()    Blob  $name ,  $length ,  nullable = false ,  $default = null ,  array $options = array()    Boolean  $name    Char  $name ,  length    Column (generic)  $name = null    Date  $name    Decimal  $name ,  $precision ,  $scale = null    Float  $name ,  $digits ,  $decimal  (Note: this class is deprecated as of 2.4.0; use Floating instead)    Floating  $name ,  $digits ,  $decimal    Integer  $name ,  $nullable = false ,  default = null ,  array $options = array()    Text  $name ,  $length ,  nullable = false ,  $default = null ,  array $options = array()    Time  $name    Varchar  $name ,  $length     Each of the above types can be utilized in any place that accepts a  Column\\ColumnInterface \ninstance. Currently, this is primarily in  CreateTable::addColumn()  and  AlterTable 's addColumn()  and  changeColumn()  methods.",
            "title": "Currently Supported Data Types"
        },
        {
            "location": "/sql-ddl/#currently-supported-constraint-types",
            "text": "These types exist in the  Zend\\Db\\Sql\\Ddl\\Constraint  namespace. Data types\nmust implement  Zend\\Db\\Sql\\Ddl\\Constraint\\ConstraintInterface .  In alphabetical order:     Type  Arguments For Construction      Check  $expression ,  $name    ForeignKey  $name ,  $column ,  $referenceTable ,  $referenceColumn ,  $onDeleteRule = null ,  $onUpdateRule = null    PrimaryKey  $columns    UniqueKey  $column ,  $name = null     Each of the above types can be utilized in any place that accepts a Column\\ConstraintInterface  instance. Currently, this is primarily in CreateTable::addConstraint()  and  AlterTable::addConstraint() .",
            "title": "Currently Supported Constraint Types"
        },
        {
            "location": "/table-gateway/",
            "text": "Table Gateways\n\n\nThe Table Gateway subcomponent provides an object-oriented representation of a\ndatabase table; its methods mirror the most common table operations. In code,\nthe interface resembles:\n\n\nnamespace Zend\\Db\\TableGateway;\n\nuse Zend\\Db\\ResultSet\\ResultSetInterface;\nuse Zend\\Db\\Sql\\Where;\n\ninterface TableGatewayInterface\n{\n    public function getTable() : string;\n    public function select(Where|callable|string|array $where = null) : ResultSetInterface;\n    public function insert(array $set) : int;\n    public function update(\n        array $set,\n        Where|callable|string|array $where = null,\n        array $joins = null\n    ) : int;\n    public function delete(Where|callable|string|array $where) : int;\n}\n\n\n\nThere are two primary implementations of the \nTableGatewayInterface\n,\n\nAbstractTableGateway\n and \nTableGateway\n. The \nAbstractTableGateway\n is an\nabstract basic implementation that provides functionality for \nselect()\n,\n\ninsert()\n, \nupdate()\n, \ndelete()\n, as well as an additional API for doing\nthese same kinds of tasks with explicit \nZend\\Db\\Sql\n objects: \nselectWith()\n,\n\ninsertWith()\n, \nupdateWith()\n, and \ndeleteWith()\n. In addition,\nAbstractTableGateway also implements a \"Feature\" API, that allows for expanding\nthe behaviors of the base \nTableGateway\n implementation without having to\nextend the class with this new functionality.  The \nTableGateway\n concrete\nimplementation simply adds a sensible constructor to the \nAbstractTableGateway\n\nclass so that out-of-the-box, \nTableGateway\n does not need to be extended in\norder to be consumed and utilized to its fullest.\n\n\nQuick start\n\n\nThe following example uses \nZend\\Db\\TableGateway\\TableGateway\n, which defines\nthe following API:\n\n\nnamespace Zend\\Db\\TableGateway;\n\nuse Zend\\Db\\Adapter\\AdapterInterface;\nuse Zend\\Db\\ResultSet\\ResultSet;\nuse Zend\\Db\\ResultSet\\ResultSetInterface;\nuse Zend\\Db\\Sql;\nuse Zend\\Db\\Sql\\TableIdentifier;\n\nclass TableGateway extends AbstractTableGateway\n{\n    public $lastInsertValue;\n    public $table;\n    public $adapter;\n\n    public function __construct(\n        string|TableIdentifier $table,\n        AdapterInterface $adapter,\n        Feature\\AbstractFeature|Feature\\FeatureSet|Feature\\AbstractFeature[] $features = null,\n        ResultSetInterface $resultSetPrototype = null,\n        Sql\\Sql $sql = null\n    );\n\n    /** Inherited from AbstractTableGateway */\n\n    public function isInitialized() : bool;\n    public function initialize() : void;\n    public function getTable() : string;\n    public function getAdapter() : AdapterInterface;\n    public function getColumns() : array;\n    public function getFeatureSet() Feature\\FeatureSet;\n    public function getResultSetPrototype() : ResultSetInterface;\n    public function getSql() | Sql\\Sql;\n    public function select(Sql\\Where|callable|string|array $where = null) : ResultSetInterface;\n    public function selectWith(Sql\\Select $select) : ResultSetInterface;\n    public function insert(array $set) : int;\n    public function insertWith(Sql\\Insert $insert) | int;\n    public function update(\n        array $set,\n        Sql\\Where|callable|string|array $where = null,\n        array $joins = null\n    ) : int;\n    public function updateWith(Sql\\Update $update) : int;\n    public function delete(Sql\\Where|callable|string|array $where) : int;\n    public function deleteWith(Sql\\Delete $delete) : int;\n    public function getLastInsertValue() : int;\n}\n\n\n\nThe concrete \nTableGateway\n object uses constructor injection for getting\ndependencies and options into the instance. The table name and an instance of\nan \nAdapter\n are all that is required to create an instance.\n\n\nOut of the box, this implementation makes no assumptions about table structure\nor metadata, and when \nselect()\n is executed, a simple \nResultSet\n object with\nthe populated \nAdapter\n's \nResult\n (the datasource) will be returned and ready\nfor iteration.\n\n\nuse Zend\\Db\\TableGateway\\TableGateway;\n\n$projectTable = new TableGateway('project', $adapter);\n$rowset = $projectTable->select(['type' => 'PHP']);\n\necho 'Projects of type PHP: ' . PHP_EOL;\nforeach ($rowset as $projectRow) {\n    echo $projectRow['name'] . PHP_EOL;\n}\n\n// Or, when expecting a single row:\n$artistTable = new TableGateway('artist', $adapter);\n$rowset      = $artistTable->select(['id' => 2]);\n$artistRow   = $rowset->current();\n\nvar_dump($artistRow);\n\n\n\nThe \nselect()\n method takes the same arguments as\n\nZend\\Db\\Sql\\Select::where()\n; arguments will be passed to the \nSelect\n\ninstance used to build the SELECT query. This means the following is possible:\n\n\nuse Zend\\Db\\TableGateway\\TableGateway;\nuse Zend\\Db\\Sql\\Select;\n\n$artistTable = new TableGateway('artist', $adapter);\n\n// Search for at most 2 artists who's name starts with Brit, ascending:\n$rowset = $artistTable->select(function (Select $select) {\n    $select->where->like('name', 'Brit%');\n    $select->order('name ASC')->limit(2);\n});\n\n\n\nTableGateway Features\n\n\nThe Features API allows for extending the functionality of the base\n\nTableGateway\n object without having to polymorphically extend the base class.\nThis allows for a wider array of possible mixing and matching of features to\nachieve a particular behavior that needs to be attained to make the base\nimplementation of \nTableGateway\n useful for a particular problem.\n\n\nWith the \nTableGateway\n object, features should be injected though the\nconstructor. The constructor can take features in 3 different forms:\n\n\n\n\nas a single \nFeature\n instance\n\n\nas a \nFeatureSet\n instance\n\n\nas an array of \nFeature\n instances\n\n\n\n\nThere are a number of features built-in and shipped with zend-db:\n\n\n\n\n\n\nGlobalAdapterFeature\n: the ability to use a global/static adapter without\n  needing to inject it into a \nTableGateway\n instance. This is only useful when\n  you are extending the \nAbstractTableGateway\n implementation:\n\n\nuse Zend\\Db\\TableGateway\\AbstractTableGateway;\nuse Zend\\Db\\TableGateway\\Feature;\n\nclass MyTableGateway extends AbstractTableGateway\n{\n    public function __construct()\n    {\n        $this->table      = 'my_table';\n        $this->featureSet = new Feature\\FeatureSet();\n        $this->featureSet->addFeature(new Feature\\GlobalAdapterFeature());\n        $this->initialize();\n    }\n}\n\n// elsewhere in code, in a bootstrap\nZend\\Db\\TableGateway\\Feature\\GlobalAdapterFeature::setStaticAdapter($adapter);\n\n// in a controller, or model somewhere\n$table = new MyTableGateway(); // adapter is statically loaded\n\n\n\n\n\n\n\nMasterSlaveFeature\n: the ability to use a master adapter for \ninsert()\n,\n  \nupdate()\n, and \ndelete()\n, but switch to a slave adapter for all \nselect()\n\n  operations.\n\n\n$table = new TableGateway('artist', $adapter, new Feature\\MasterSlaveFeature($slaveAdapter));\n\n\n\n\n\n\n\nMetadataFeature\n: the ability populate \nTableGateway\n with column\n  information from a \nMetadata\n object. It will also store the primary key\n  information in case the \nRowGatewayFeature\n needs to consume this information.\n\n\n$table = new TableGateway('artist', $adapter, new Feature\\MetadataFeature());\n\n\n\n\n\n\n\nEventFeature\n: the ability to compose a\n  \nzend-eventmanager\n\n  \nEventManager\n instance within your \nTableGateway\n instance, and attach\n  listeners to the various events of its lifecycle.\n\n\n$table = new TableGateway('artist', $adapter, new Feature\\EventFeature($eventManagerInstance));\n\n\n\n\n\n\n\nRowGatewayFeature\n: the ability for \nselect()\n to return a \nResultSet\n object that upon iteration\n  will return a \nRowGateway\n instance for each row.\n\n\n$table   = new TableGateway('artist', $adapter, new Feature\\RowGatewayFeature('id'));\n$results = $table->select(['id' => 2]);\n\n$artistRow       = $results->current();\n$artistRow->name = 'New Name';\n$artistRow->save();",
            "title": "Table Gateways"
        },
        {
            "location": "/table-gateway/#table-gateways",
            "text": "The Table Gateway subcomponent provides an object-oriented representation of a\ndatabase table; its methods mirror the most common table operations. In code,\nthe interface resembles:  namespace Zend\\Db\\TableGateway;\n\nuse Zend\\Db\\ResultSet\\ResultSetInterface;\nuse Zend\\Db\\Sql\\Where;\n\ninterface TableGatewayInterface\n{\n    public function getTable() : string;\n    public function select(Where|callable|string|array $where = null) : ResultSetInterface;\n    public function insert(array $set) : int;\n    public function update(\n        array $set,\n        Where|callable|string|array $where = null,\n        array $joins = null\n    ) : int;\n    public function delete(Where|callable|string|array $where) : int;\n}  There are two primary implementations of the  TableGatewayInterface , AbstractTableGateway  and  TableGateway . The  AbstractTableGateway  is an\nabstract basic implementation that provides functionality for  select() , insert() ,  update() ,  delete() , as well as an additional API for doing\nthese same kinds of tasks with explicit  Zend\\Db\\Sql  objects:  selectWith() , insertWith() ,  updateWith() , and  deleteWith() . In addition,\nAbstractTableGateway also implements a \"Feature\" API, that allows for expanding\nthe behaviors of the base  TableGateway  implementation without having to\nextend the class with this new functionality.  The  TableGateway  concrete\nimplementation simply adds a sensible constructor to the  AbstractTableGateway \nclass so that out-of-the-box,  TableGateway  does not need to be extended in\norder to be consumed and utilized to its fullest.",
            "title": "Table Gateways"
        },
        {
            "location": "/table-gateway/#quick-start",
            "text": "The following example uses  Zend\\Db\\TableGateway\\TableGateway , which defines\nthe following API:  namespace Zend\\Db\\TableGateway;\n\nuse Zend\\Db\\Adapter\\AdapterInterface;\nuse Zend\\Db\\ResultSet\\ResultSet;\nuse Zend\\Db\\ResultSet\\ResultSetInterface;\nuse Zend\\Db\\Sql;\nuse Zend\\Db\\Sql\\TableIdentifier;\n\nclass TableGateway extends AbstractTableGateway\n{\n    public $lastInsertValue;\n    public $table;\n    public $adapter;\n\n    public function __construct(\n        string|TableIdentifier $table,\n        AdapterInterface $adapter,\n        Feature\\AbstractFeature|Feature\\FeatureSet|Feature\\AbstractFeature[] $features = null,\n        ResultSetInterface $resultSetPrototype = null,\n        Sql\\Sql $sql = null\n    );\n\n    /** Inherited from AbstractTableGateway */\n\n    public function isInitialized() : bool;\n    public function initialize() : void;\n    public function getTable() : string;\n    public function getAdapter() : AdapterInterface;\n    public function getColumns() : array;\n    public function getFeatureSet() Feature\\FeatureSet;\n    public function getResultSetPrototype() : ResultSetInterface;\n    public function getSql() | Sql\\Sql;\n    public function select(Sql\\Where|callable|string|array $where = null) : ResultSetInterface;\n    public function selectWith(Sql\\Select $select) : ResultSetInterface;\n    public function insert(array $set) : int;\n    public function insertWith(Sql\\Insert $insert) | int;\n    public function update(\n        array $set,\n        Sql\\Where|callable|string|array $where = null,\n        array $joins = null\n    ) : int;\n    public function updateWith(Sql\\Update $update) : int;\n    public function delete(Sql\\Where|callable|string|array $where) : int;\n    public function deleteWith(Sql\\Delete $delete) : int;\n    public function getLastInsertValue() : int;\n}  The concrete  TableGateway  object uses constructor injection for getting\ndependencies and options into the instance. The table name and an instance of\nan  Adapter  are all that is required to create an instance.  Out of the box, this implementation makes no assumptions about table structure\nor metadata, and when  select()  is executed, a simple  ResultSet  object with\nthe populated  Adapter 's  Result  (the datasource) will be returned and ready\nfor iteration.  use Zend\\Db\\TableGateway\\TableGateway;\n\n$projectTable = new TableGateway('project', $adapter);\n$rowset = $projectTable->select(['type' => 'PHP']);\n\necho 'Projects of type PHP: ' . PHP_EOL;\nforeach ($rowset as $projectRow) {\n    echo $projectRow['name'] . PHP_EOL;\n}\n\n// Or, when expecting a single row:\n$artistTable = new TableGateway('artist', $adapter);\n$rowset      = $artistTable->select(['id' => 2]);\n$artistRow   = $rowset->current();\n\nvar_dump($artistRow);  The  select()  method takes the same arguments as Zend\\Db\\Sql\\Select::where() ; arguments will be passed to the  Select \ninstance used to build the SELECT query. This means the following is possible:  use Zend\\Db\\TableGateway\\TableGateway;\nuse Zend\\Db\\Sql\\Select;\n\n$artistTable = new TableGateway('artist', $adapter);\n\n// Search for at most 2 artists who's name starts with Brit, ascending:\n$rowset = $artistTable->select(function (Select $select) {\n    $select->where->like('name', 'Brit%');\n    $select->order('name ASC')->limit(2);\n});",
            "title": "Quick start"
        },
        {
            "location": "/table-gateway/#tablegateway-features",
            "text": "The Features API allows for extending the functionality of the base TableGateway  object without having to polymorphically extend the base class.\nThis allows for a wider array of possible mixing and matching of features to\nachieve a particular behavior that needs to be attained to make the base\nimplementation of  TableGateway  useful for a particular problem.  With the  TableGateway  object, features should be injected though the\nconstructor. The constructor can take features in 3 different forms:   as a single  Feature  instance  as a  FeatureSet  instance  as an array of  Feature  instances   There are a number of features built-in and shipped with zend-db:    GlobalAdapterFeature : the ability to use a global/static adapter without\n  needing to inject it into a  TableGateway  instance. This is only useful when\n  you are extending the  AbstractTableGateway  implementation:  use Zend\\Db\\TableGateway\\AbstractTableGateway;\nuse Zend\\Db\\TableGateway\\Feature;\n\nclass MyTableGateway extends AbstractTableGateway\n{\n    public function __construct()\n    {\n        $this->table      = 'my_table';\n        $this->featureSet = new Feature\\FeatureSet();\n        $this->featureSet->addFeature(new Feature\\GlobalAdapterFeature());\n        $this->initialize();\n    }\n}\n\n// elsewhere in code, in a bootstrap\nZend\\Db\\TableGateway\\Feature\\GlobalAdapterFeature::setStaticAdapter($adapter);\n\n// in a controller, or model somewhere\n$table = new MyTableGateway(); // adapter is statically loaded    MasterSlaveFeature : the ability to use a master adapter for  insert() ,\n   update() , and  delete() , but switch to a slave adapter for all  select() \n  operations.  $table = new TableGateway('artist', $adapter, new Feature\\MasterSlaveFeature($slaveAdapter));    MetadataFeature : the ability populate  TableGateway  with column\n  information from a  Metadata  object. It will also store the primary key\n  information in case the  RowGatewayFeature  needs to consume this information.  $table = new TableGateway('artist', $adapter, new Feature\\MetadataFeature());    EventFeature : the ability to compose a\n   zend-eventmanager \n   EventManager  instance within your  TableGateway  instance, and attach\n  listeners to the various events of its lifecycle.  $table = new TableGateway('artist', $adapter, new Feature\\EventFeature($eventManagerInstance));    RowGatewayFeature : the ability for  select()  to return a  ResultSet  object that upon iteration\n  will return a  RowGateway  instance for each row.  $table   = new TableGateway('artist', $adapter, new Feature\\RowGatewayFeature('id'));\n$results = $table->select(['id' => 2]);\n\n$artistRow       = $results->current();\n$artistRow->name = 'New Name';\n$artistRow->save();",
            "title": "TableGateway Features"
        },
        {
            "location": "/row-gateway/",
            "text": "Row Gateways\n\n\nZend\\Db\\RowGateway\n is a sub-component of zend-db that implements the Row Data\nGateway pattern described in the book \nPatterns of Enterprise Application\nArchitecture\n. Row Data Gateways\nmodel individual rows of a database table, and provide methods such as \nsave()\n\nand \ndelete()\n that persist the row to the database. Likewise, after a row from\nthe database is retrieved, it can then be manipulated and \nsave()\n'd back to\nthe database in the same position (row), or it can be \ndelete()\n'd from the\ntable.\n\n\nRowGatewayInterface\n defines the methods \nsave()\n and \ndelete()\n:\n\n\nnamespace Zend\\Db\\RowGateway;\n\ninterface RowGatewayInterface\n{\n    public function save();\n    public function delete();\n}\n\n\n\nQuick start\n\n\nRowGateway\n is generally used in conjunction with objects that produce\n\nZend\\Db\\ResultSet\ns, though it may also be used standalone.  To use it\nstandalone, you need an \nAdapter\n instance and a set of data to work with.\n\n\nThe following demonstrates a basic use case.\n\n\nuse Zend\\Db\\RowGateway\\RowGateway;\n\n// Query the database:\n$resultSet = $adapter->query('SELECT * FROM `user` WHERE `id` = ?', [2]);\n\n// Get array of data:\n$rowData = $resultSet->current()->getArrayCopy();\n\n// Create a row gateway:\n$rowGateway = new RowGateway('id', 'my_table', $adapter);\n$rowGateway->populate($rowData, true);\n\n// Manipulate the row and persist it:\n$rowGateway->first_name = 'New Name';\n$rowGateway->save();\n\n// Or delete this row:\n$rowGateway->delete();\n\n\n\nThe workflow described above is greatly simplified when \nRowGateway\n is used in\nconjunction with the \nTableGateway RowGatewayFeature\n.\nIn that paradigm, \nselect()\n operations will produce a \nResultSet\n that iterates\n\nRowGateway\n instances.\n\n\nAs an example:\n\n\nuse Zend\\Db\\TableGateway\\Feature\\RowGatewayFeature;\nuse Zend\\Db\\TableGateway\\TableGateway;\n\n$table = new TableGateway('artist', $adapter, new RowGatewayFeature('id'));\n$results = $table->select(['id' => 2]);\n\n$artistRow = $results->current();\n$artistRow->name = 'New Name';\n$artistRow->save();\n\n\n\nActiveRecord Style Objects\n\n\nIf you wish to have custom behaviour in your \nRowGateway\n objects \u2014\nessentially making them behave similarly to the\n\nActiveRecord\n\npattern), pass a prototype object implementing the \nRowGatewayInterface\n to the\n\nRowGatewayFeature\n constructor instead of a primary key:\n\n\nuse Zend\\Db\\TableGateway\\Feature\\RowGatewayFeature;\nuse Zend\\Db\\TableGateway\\TableGateway;\nuse Zend\\Db\\RowGateway\\RowGatewayInterface;\n\nclass Artist implements RowGatewayInterface\n{\n    protected $adapter;\n\n    public function __construct($adapter)\n    {\n       $this->adapter = $adapter;\n    }\n\n    // ... save() and delete() implementations\n}\n\n$table = new TableGateway('artist', $adapter, new RowGatewayFeature(new Artist($adapter)));",
            "title": "Row Gateways"
        },
        {
            "location": "/row-gateway/#row-gateways",
            "text": "Zend\\Db\\RowGateway  is a sub-component of zend-db that implements the Row Data\nGateway pattern described in the book  Patterns of Enterprise Application\nArchitecture . Row Data Gateways\nmodel individual rows of a database table, and provide methods such as  save() \nand  delete()  that persist the row to the database. Likewise, after a row from\nthe database is retrieved, it can then be manipulated and  save() 'd back to\nthe database in the same position (row), or it can be  delete() 'd from the\ntable.  RowGatewayInterface  defines the methods  save()  and  delete() :  namespace Zend\\Db\\RowGateway;\n\ninterface RowGatewayInterface\n{\n    public function save();\n    public function delete();\n}",
            "title": "Row Gateways"
        },
        {
            "location": "/row-gateway/#quick-start",
            "text": "RowGateway  is generally used in conjunction with objects that produce Zend\\Db\\ResultSet s, though it may also be used standalone.  To use it\nstandalone, you need an  Adapter  instance and a set of data to work with.  The following demonstrates a basic use case.  use Zend\\Db\\RowGateway\\RowGateway;\n\n// Query the database:\n$resultSet = $adapter->query('SELECT * FROM `user` WHERE `id` = ?', [2]);\n\n// Get array of data:\n$rowData = $resultSet->current()->getArrayCopy();\n\n// Create a row gateway:\n$rowGateway = new RowGateway('id', 'my_table', $adapter);\n$rowGateway->populate($rowData, true);\n\n// Manipulate the row and persist it:\n$rowGateway->first_name = 'New Name';\n$rowGateway->save();\n\n// Or delete this row:\n$rowGateway->delete();  The workflow described above is greatly simplified when  RowGateway  is used in\nconjunction with the  TableGateway RowGatewayFeature .\nIn that paradigm,  select()  operations will produce a  ResultSet  that iterates RowGateway  instances.  As an example:  use Zend\\Db\\TableGateway\\Feature\\RowGatewayFeature;\nuse Zend\\Db\\TableGateway\\TableGateway;\n\n$table = new TableGateway('artist', $adapter, new RowGatewayFeature('id'));\n$results = $table->select(['id' => 2]);\n\n$artistRow = $results->current();\n$artistRow->name = 'New Name';\n$artistRow->save();",
            "title": "Quick start"
        },
        {
            "location": "/row-gateway/#activerecord-style-objects",
            "text": "If you wish to have custom behaviour in your  RowGateway  objects \u2014\nessentially making them behave similarly to the ActiveRecord \npattern), pass a prototype object implementing the  RowGatewayInterface  to the RowGatewayFeature  constructor instead of a primary key:  use Zend\\Db\\TableGateway\\Feature\\RowGatewayFeature;\nuse Zend\\Db\\TableGateway\\TableGateway;\nuse Zend\\Db\\RowGateway\\RowGatewayInterface;\n\nclass Artist implements RowGatewayInterface\n{\n    protected $adapter;\n\n    public function __construct($adapter)\n    {\n       $this->adapter = $adapter;\n    }\n\n    // ... save() and delete() implementations\n}\n\n$table = new TableGateway('artist', $adapter, new RowGatewayFeature(new Artist($adapter)));",
            "title": "ActiveRecord Style Objects"
        },
        {
            "location": "/metadata/",
            "text": "RDBMS Metadata\n\n\nZend\\Db\\Metadata\n is as sub-component of zend-db that makes it possible to get\nmetadata information about tables, columns, constraints, triggers, and other\ninformation from a database in a standardized way. The primary interface for\n\nMetadata\n is:\n\n\nnamespace Zend\\Db\\Metadata;\n\ninterface MetadataInterface\n{\n    public function getSchemas();\n\n    public function getTableNames(string $schema = null, bool $includeViews = false) : string[];\n    public function getTables(string $schema = null, bool $includeViews = false) : Object\\TableObject[];\n    public function getTable(string $tableName, string $schema = null) : Object\\TableObject;\n\n    public function getViewNames(string $schema = null) : string[];\n    public function getViews(string $schema = null) : Object\\ViewObject[];\n    public function getView(string $viewName, string $schema = null) : Object\\ViewObject;\n\n    public function getColumnNames(string string $table, $schema = null) : string[];\n    public function getColumns(string $table, string $schema = null) : Object\\ColumnObject[];\n    public function getColumn(string $columnName, string $table, string $schema = null) Object\\ColumnObject;\n\n    public function getConstraints(string $table, $string schema = null) : Object\\ConstraintObject[];\n    public function getConstraint(string $constraintName, string $table, string $schema = null) : Object\\ConstraintObject;\n    public function getConstraintKeys(string $constraint, string $table, string $schema = null) : Object\\ConstraintKeyObject[];\n\n    public function getTriggerNames(string $schema = null) : string[];\n    public function getTriggers(string $schema = null) : Object\\TriggerObject[];\n    public function getTrigger(string $triggerName, string $schema = null) : Object\\TriggerObject;\n}\n\n\n\nBasic Usage\n\n\nUsage of \nZend\\Db\\Metadata\n involves:\n\n\n\n\nConstructing a \nZend\\Db\\Metadata\\Metadata\n instance with an \nAdapter\n.\n\n\nChoosing a strategy for retrieving metadata, based on the database platform\n  used. In most cases, information will come from querying the\n  \nINFORMATION_SCHEMA\n tables for the currently accessible schema.\n\n\n\n\nThe \nMetadata::get*Names()\n methods will return arrays of strings, while the\nother methods will return value objects specific to the type queried.\n\n\n$metadata = new Zend\\Db\\Metadata\\Metadata($adapter);\n\n// get the table names\n$tableNames = $metadata->getTableNames();\n\nforeach ($tableNames as $tableName) {\n    echo 'In Table ' . $tableName . PHP_EOL;\n\n    $table = $metadata->getTable($tableName);\n\n    echo '    With columns: ' . PHP_EOL;\n    foreach ($table->getColumns() as $column) {\n        echo '        ' . $column->getName()\n            . ' -> ' . $column->getDataType()\n            . PHP_EOL;\n    }\n\n    echo PHP_EOL;\n    echo '    With constraints: ' . PHP_EOL;\n\n    foreach ($metadata->getConstraints($tableName) as $constraint) {\n        echo '        ' . $constraint->getName()\n            . ' -> ' . $constraint->getType()\n            . PHP_EOL;\n\n        if (! $constraint->hasColumns()) {\n            continue;\n        }\n\n        echo '            column: ' . implode(', ', $constraint->getColumns());\n        if ($constraint->isForeignKey()) {\n            $fkCols = [];\n            foreach ($constraint->getReferencedColumns() as $refColumn) {\n                $fkCols[] = $constraint->getReferencedTableName() . '.' . $refColumn;\n            }\n            echo ' => ' . implode(', ', $fkCols);\n        }\n\n        echo PHP_EOL;\n    }\n\n    echo '----' . PHP_EOL;\n}\n\n\n\nMetadata value objects\n\n\nMetadata returns value objects that provide an interface to help developers\nbetter explore the metadata. Below is the API for the various value objects:\n\n\nTableObject\n\n\nclass Zend\\Db\\Metadata\\Object\\TableObject\n{\n    public function __construct($name);\n    public function setColumns(array $columns);\n    public function getColumns();\n    public function setConstraints($constraints);\n    public function getConstraints();\n    public function setName($name);\n    public function getName();\n}\n\n\n\nColumnObject\n\n\nclass Zend\\Db\\Metadata\\Object\\ColumnObject\n{\n    public function __construct($name, $tableName, $schemaName = null);\n    public function setName($name);\n    public function getName();\n    public function getTableName();\n    public function setTableName($tableName);\n    public function setSchemaName($schemaName);\n    public function getSchemaName();\n    public function getOrdinalPosition();\n    public function setOrdinalPosition($ordinalPosition);\n    public function getColumnDefault();\n    public function setColumnDefault($columnDefault);\n    public function getIsNullable();\n    public function setIsNullable($isNullable);\n    public function isNullable();\n    public function getDataType();\n    public function setDataType($dataType);\n    public function getCharacterMaximumLength();\n    public function setCharacterMaximumLength($characterMaximumLength);\n    public function getCharacterOctetLength();\n    public function setCharacterOctetLength($characterOctetLength);\n    public function getNumericPrecision();\n    public function setNumericPrecision($numericPrecision);\n    public function getNumericScale();\n    public function setNumericScale($numericScale);\n    public function getNumericUnsigned();\n    public function setNumericUnsigned($numericUnsigned);\n    public function isNumericUnsigned();\n    public function getErratas();\n    public function setErratas(array $erratas);\n    public function getErrata($errataName);\n    public function setErrata($errataName, $errataValue);\n}\n\n\n\nConstraintObject\n\n\nclass Zend\\Db\\Metadata\\Object\\ConstraintObject\n{\n    public function __construct($name, $tableName, $schemaName = null);\n    public function setName($name);\n    public function getName();\n    public function setSchemaName($schemaName);\n    public function getSchemaName();\n    public function getTableName();\n    public function setTableName($tableName);\n    public function setType($type);\n    public function getType();\n    public function hasColumns();\n    public function getColumns();\n    public function setColumns(array $columns);\n    public function getReferencedTableSchema();\n    public function setReferencedTableSchema($referencedTableSchema);\n    public function getReferencedTableName();\n    public function setReferencedTableName($referencedTableName);\n    public function getReferencedColumns();\n    public function setReferencedColumns(array $referencedColumns);\n    public function getMatchOption();\n    public function setMatchOption($matchOption);\n    public function getUpdateRule();\n    public function setUpdateRule($updateRule);\n    public function getDeleteRule();\n    public function setDeleteRule($deleteRule);\n    public function getCheckClause();\n    public function setCheckClause($checkClause);\n    public function isPrimaryKey();\n    public function isUnique();\n    public function isForeignKey();\n    public function isCheck();\n\n}\n\n\n\nTriggerObject\n\n\nclass Zend\\Db\\Metadata\\Object\\TriggerObject\n{\n    public function getName();\n    public function setName($name);\n    public function getEventManipulation();\n    public function setEventManipulation($eventManipulation);\n    public function getEventObjectCatalog();\n    public function setEventObjectCatalog($eventObjectCatalog);\n    public function getEventObjectSchema();\n    public function setEventObjectSchema($eventObjectSchema);\n    public function getEventObjectTable();\n    public function setEventObjectTable($eventObjectTable);\n    public function getActionOrder();\n    public function setActionOrder($actionOrder);\n    public function getActionCondition();\n    public function setActionCondition($actionCondition);\n    public function getActionStatement();\n    public function setActionStatement($actionStatement);\n    public function getActionOrientation();\n    public function setActionOrientation($actionOrientation);\n    public function getActionTiming();\n    public function setActionTiming($actionTiming);\n    public function getActionReferenceOldTable();\n    public function setActionReferenceOldTable($actionReferenceOldTable);\n    public function getActionReferenceNewTable();\n    public function setActionReferenceNewTable($actionReferenceNewTable);\n    public function getActionReferenceOldRow();\n    public function setActionReferenceOldRow($actionReferenceOldRow);\n    public function getActionReferenceNewRow();\n    public function setActionReferenceNewRow($actionReferenceNewRow);\n    public function getCreated();\n    public function setCreated($created);\n}",
            "title": "RDBMS Metadata"
        },
        {
            "location": "/metadata/#rdbms-metadata",
            "text": "Zend\\Db\\Metadata  is as sub-component of zend-db that makes it possible to get\nmetadata information about tables, columns, constraints, triggers, and other\ninformation from a database in a standardized way. The primary interface for Metadata  is:  namespace Zend\\Db\\Metadata;\n\ninterface MetadataInterface\n{\n    public function getSchemas();\n\n    public function getTableNames(string $schema = null, bool $includeViews = false) : string[];\n    public function getTables(string $schema = null, bool $includeViews = false) : Object\\TableObject[];\n    public function getTable(string $tableName, string $schema = null) : Object\\TableObject;\n\n    public function getViewNames(string $schema = null) : string[];\n    public function getViews(string $schema = null) : Object\\ViewObject[];\n    public function getView(string $viewName, string $schema = null) : Object\\ViewObject;\n\n    public function getColumnNames(string string $table, $schema = null) : string[];\n    public function getColumns(string $table, string $schema = null) : Object\\ColumnObject[];\n    public function getColumn(string $columnName, string $table, string $schema = null) Object\\ColumnObject;\n\n    public function getConstraints(string $table, $string schema = null) : Object\\ConstraintObject[];\n    public function getConstraint(string $constraintName, string $table, string $schema = null) : Object\\ConstraintObject;\n    public function getConstraintKeys(string $constraint, string $table, string $schema = null) : Object\\ConstraintKeyObject[];\n\n    public function getTriggerNames(string $schema = null) : string[];\n    public function getTriggers(string $schema = null) : Object\\TriggerObject[];\n    public function getTrigger(string $triggerName, string $schema = null) : Object\\TriggerObject;\n}",
            "title": "RDBMS Metadata"
        },
        {
            "location": "/metadata/#basic-usage",
            "text": "Usage of  Zend\\Db\\Metadata  involves:   Constructing a  Zend\\Db\\Metadata\\Metadata  instance with an  Adapter .  Choosing a strategy for retrieving metadata, based on the database platform\n  used. In most cases, information will come from querying the\n   INFORMATION_SCHEMA  tables for the currently accessible schema.   The  Metadata::get*Names()  methods will return arrays of strings, while the\nother methods will return value objects specific to the type queried.  $metadata = new Zend\\Db\\Metadata\\Metadata($adapter);\n\n// get the table names\n$tableNames = $metadata->getTableNames();\n\nforeach ($tableNames as $tableName) {\n    echo 'In Table ' . $tableName . PHP_EOL;\n\n    $table = $metadata->getTable($tableName);\n\n    echo '    With columns: ' . PHP_EOL;\n    foreach ($table->getColumns() as $column) {\n        echo '        ' . $column->getName()\n            . ' -> ' . $column->getDataType()\n            . PHP_EOL;\n    }\n\n    echo PHP_EOL;\n    echo '    With constraints: ' . PHP_EOL;\n\n    foreach ($metadata->getConstraints($tableName) as $constraint) {\n        echo '        ' . $constraint->getName()\n            . ' -> ' . $constraint->getType()\n            . PHP_EOL;\n\n        if (! $constraint->hasColumns()) {\n            continue;\n        }\n\n        echo '            column: ' . implode(', ', $constraint->getColumns());\n        if ($constraint->isForeignKey()) {\n            $fkCols = [];\n            foreach ($constraint->getReferencedColumns() as $refColumn) {\n                $fkCols[] = $constraint->getReferencedTableName() . '.' . $refColumn;\n            }\n            echo ' => ' . implode(', ', $fkCols);\n        }\n\n        echo PHP_EOL;\n    }\n\n    echo '----' . PHP_EOL;\n}",
            "title": "Basic Usage"
        },
        {
            "location": "/metadata/#metadata-value-objects",
            "text": "Metadata returns value objects that provide an interface to help developers\nbetter explore the metadata. Below is the API for the various value objects:",
            "title": "Metadata value objects"
        },
        {
            "location": "/metadata/#tableobject",
            "text": "class Zend\\Db\\Metadata\\Object\\TableObject\n{\n    public function __construct($name);\n    public function setColumns(array $columns);\n    public function getColumns();\n    public function setConstraints($constraints);\n    public function getConstraints();\n    public function setName($name);\n    public function getName();\n}",
            "title": "TableObject"
        },
        {
            "location": "/metadata/#columnobject",
            "text": "class Zend\\Db\\Metadata\\Object\\ColumnObject\n{\n    public function __construct($name, $tableName, $schemaName = null);\n    public function setName($name);\n    public function getName();\n    public function getTableName();\n    public function setTableName($tableName);\n    public function setSchemaName($schemaName);\n    public function getSchemaName();\n    public function getOrdinalPosition();\n    public function setOrdinalPosition($ordinalPosition);\n    public function getColumnDefault();\n    public function setColumnDefault($columnDefault);\n    public function getIsNullable();\n    public function setIsNullable($isNullable);\n    public function isNullable();\n    public function getDataType();\n    public function setDataType($dataType);\n    public function getCharacterMaximumLength();\n    public function setCharacterMaximumLength($characterMaximumLength);\n    public function getCharacterOctetLength();\n    public function setCharacterOctetLength($characterOctetLength);\n    public function getNumericPrecision();\n    public function setNumericPrecision($numericPrecision);\n    public function getNumericScale();\n    public function setNumericScale($numericScale);\n    public function getNumericUnsigned();\n    public function setNumericUnsigned($numericUnsigned);\n    public function isNumericUnsigned();\n    public function getErratas();\n    public function setErratas(array $erratas);\n    public function getErrata($errataName);\n    public function setErrata($errataName, $errataValue);\n}",
            "title": "ColumnObject"
        },
        {
            "location": "/metadata/#constraintobject",
            "text": "class Zend\\Db\\Metadata\\Object\\ConstraintObject\n{\n    public function __construct($name, $tableName, $schemaName = null);\n    public function setName($name);\n    public function getName();\n    public function setSchemaName($schemaName);\n    public function getSchemaName();\n    public function getTableName();\n    public function setTableName($tableName);\n    public function setType($type);\n    public function getType();\n    public function hasColumns();\n    public function getColumns();\n    public function setColumns(array $columns);\n    public function getReferencedTableSchema();\n    public function setReferencedTableSchema($referencedTableSchema);\n    public function getReferencedTableName();\n    public function setReferencedTableName($referencedTableName);\n    public function getReferencedColumns();\n    public function setReferencedColumns(array $referencedColumns);\n    public function getMatchOption();\n    public function setMatchOption($matchOption);\n    public function getUpdateRule();\n    public function setUpdateRule($updateRule);\n    public function getDeleteRule();\n    public function setDeleteRule($deleteRule);\n    public function getCheckClause();\n    public function setCheckClause($checkClause);\n    public function isPrimaryKey();\n    public function isUnique();\n    public function isForeignKey();\n    public function isCheck();\n\n}",
            "title": "ConstraintObject"
        },
        {
            "location": "/metadata/#triggerobject",
            "text": "class Zend\\Db\\Metadata\\Object\\TriggerObject\n{\n    public function getName();\n    public function setName($name);\n    public function getEventManipulation();\n    public function setEventManipulation($eventManipulation);\n    public function getEventObjectCatalog();\n    public function setEventObjectCatalog($eventObjectCatalog);\n    public function getEventObjectSchema();\n    public function setEventObjectSchema($eventObjectSchema);\n    public function getEventObjectTable();\n    public function setEventObjectTable($eventObjectTable);\n    public function getActionOrder();\n    public function setActionOrder($actionOrder);\n    public function getActionCondition();\n    public function setActionCondition($actionCondition);\n    public function getActionStatement();\n    public function setActionStatement($actionStatement);\n    public function getActionOrientation();\n    public function setActionOrientation($actionOrientation);\n    public function getActionTiming();\n    public function setActionTiming($actionTiming);\n    public function getActionReferenceOldTable();\n    public function setActionReferenceOldTable($actionReferenceOldTable);\n    public function getActionReferenceNewTable();\n    public function setActionReferenceNewTable($actionReferenceNewTable);\n    public function getActionReferenceOldRow();\n    public function setActionReferenceOldRow($actionReferenceOldRow);\n    public function getActionReferenceNewRow();\n    public function setActionReferenceNewRow($actionReferenceNewRow);\n    public function getCreated();\n    public function setCreated($created);\n}",
            "title": "TriggerObject"
        }
    ]
}